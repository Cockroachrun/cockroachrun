<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Cockroach Run - Ultimate Test</title>
  <!-- Load Three.js libraries from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
  <!-- Load Cannon.js physics engine -->
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background-color: #303030;
      color: #ffffff;
      font-family: Arial, sans-serif;
      position: fixed; /* Prevent bounce on mobile */
      touch-action: manipulation; /* Improve touch response */
    }
    
    #game-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
    }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      #debug-info {
        font-size: 10px;
        max-height: 25%;
      }
      
      #touch-controls {
        bottom: 10px;
      }
    }
    
    #game-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #121212;
    }
    
    #instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(18, 18, 18, 0.8);
      color: #00FF66;
      padding: 10px;
      border: 1px solid #00FF66;
      border-radius: 5px;
      z-index: 1000;
    }
    
    #debug-info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background-color: rgba(18, 18, 18, 0.8);
      color: #00FF66;
      padding: 10px;
      border: 1px solid #00FF66;
      border-radius: 5px;
      z-index: 1000;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    button {
      background-color: #9333EA;
      color: white;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 3px;
      margin: 5px;
    }
    
    button:hover {
      background-color: #7B2AC5;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas"></canvas>
  </div>
  
  <div id="instructions">
    <h3>Controls:</h3>
    <p>W/Up Arrow - Move Forward</p>
    <p>S/Down Arrow - Move Backward</p>
    <p>A/Left Arrow - Rotate Left</p>
    <p>D/Right Arrow - Rotate Right</p>
    <p>Space - Jump</p>
    <p>T - Toggle Debug Camera</p>
  </div>
  
  <div id="debug-info">
    <div style="font-weight: bold;">COCKROACH RUN</div>
    <div>Loading game...</div>
  </div>

  <script>
    // Immediately executing function to avoid global namespace pollution
    (function() {
      // Global variables
      let scene, camera, renderer;
      let world, cockroachModel, cockroachBody;
      let clock, controls;
      let keys = {};
      let isJumping = false;
      let jumpTime = 0;
      let jumpHeight = 0;
      let debugMode = false;
      let frameCount = 0;
      let orbitControls = null;
      
      // Enhanced log with color-coded messages and categories
      function log(message, type = 'info') {
        const debugInfo = document.getElementById('debug-info');
        if (debugInfo) {
          const timestamp = new Date().toISOString().substr(11, 8);
          const logEntry = document.createElement('div');
          
          // Color code by type
          let color = '#00FF66'; // Default cyberpunk green
          switch(type) {
            case 'error': color = '#FF3366'; break; // Red for errors
            case 'warn': color = '#FFCC00'; break;  // Yellow for warnings
            case 'move': color = '#9333EA'; break;  // Purple for movement
            case 'input': color = '#00CCFF'; break; // Blue for input events
          }
          
          // Style with cyberpunk flair
          logEntry.innerHTML = `<span style="color:#666666">[${timestamp}]</span> <span style="color:${color}">${message}</span>`;
          debugInfo.appendChild(logEntry);
          
          // Scroll to bottom
          debugInfo.scrollTop = debugInfo.scrollHeight;
          
          // Limit entries
          while (debugInfo.childElementCount > 50) {
            debugInfo.removeChild(debugInfo.firstChild);
          }
        }
        console.log(`[${type.toUpperCase()}] ${message}`);
      }
      
      // Initialize the game when the DOM is loaded
      window.onload = function() {
        init();
      };
      
      // Get URL parameters (for mode and character selection)
      const urlParams = new URLSearchParams(window.location.search);
      const selectedMode = urlParams.get('mode') || 'free-world';
      const selectedCharacter = urlParams.get('character') || 'default-roach';
      
      log(`Selected mode: ${selectedMode}, character: ${selectedCharacter}`);
      
      // Main game variables
      // Canvas is managed directly by renderer
      
      // Input state
      keys = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        jump: false
      };
      
      // Initialize the game
      function init() {
        log('========================================', 'info');
        log('COCKROACH RUN - GAME INITIALIZING', 'info');
        log('========================================', 'info');
        
        try {
          // Log character and mode selection
          log(`Selected mode: ${selectedMode}, character: ${selectedCharacter}`, 'info');
          
          // Create clock for timing
          clock = new THREE.Clock();
          
          // Reset key states
          keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false
          };
          
          // Set jump variables
          isJumping = false;
          jumpTime = 0;
          jumpHeight = 0;
          
          // Other initialization variables
          debugMode = false;
          frameCount = 0;
          
          log('Setting up Three.js...', 'info');
          
          // Create renderer directly here to avoid reassignment issues
          const gameContainer = document.getElementById('game-container');
          gameContainer.innerHTML = ''; // Clear any previous content
          
          // Enhanced window resize handling for mobile
          function onWindowResize() {
            if (camera && renderer) {
              // Get actual viewport dimensions
              const width = window.innerWidth;
              const height = window.innerHeight;
              
              // Update camera and renderer
              camera.aspect = width / height;
              camera.updateProjectionMatrix();
              renderer.setSize(width, height, true); // true for updateStyle
              
              // Log resize for debugging
              log(`Viewport resized: ${width}x${height}`, 'info');
            }
          }
          window.addEventListener('resize', onWindowResize, false);
          
          renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.shadowMap.enabled = true;
          gameContainer.appendChild(renderer.domElement);
          
          // Create scene
          scene = new THREE.Scene();
          scene.background = new THREE.Color(0x505050); // Simple grey background       
          // Create camera
          camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          camera.position.set(0, 5, 10);
          
          // Create basic scene elements
          createSceneElements();
          
          // Setup debug controls if needed
          if (debugMode) {
            try {
              orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
              log('Debug controls enabled', 'info');
            } catch (e) {
              log('Could not create orbit controls: ' + e.message, 'warn');
            }
          }
          
          // Initialize physics
          initPhysics();
          
          // Load cockroach model
          loadCockroachModel();
          
          // Setup input handlers
          setupInputHandlers();
          
          // Start animation loop
          animate();
          
          log('Game initialization complete', 'info');
          log('========================================', 'info');
          log('Use WASD or arrow keys to move', 'info');
          log('Press SPACE to jump', 'info');
          log('Press T to toggle debug mode', 'info');
          log('========================================', 'info');
          
          // Inform parent we're loaded
          sendLoadedMessage();
          
          return true;
        } catch (error) {
          log(`CRITICAL ERROR during initialization: ${error.message}`, 'error');
          console.error('Game initialization error:', error);
          return false;
        }
      }
      
      // Send message to parent that game is loaded
      function sendLoadedMessage() {
        try {
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({
              type: 'game-loaded',
              status: 'success'
            }, '*');
            log('Sent loaded message to parent', 'info');
          }
        } catch (e) {
          console.error('Error sending loaded message:', e);
        }
      }
      
      // Create basic scene elements (lights, ground, grid)
      function createSceneElements() {
        try {
          log('Creating scene elements...', 'info');
          
          // Add basic white lights
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
          scene.add(ambientLight);
          
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(10, 10, 10);
          directionalLight.castShadow = true;
          scene.add(directionalLight);
          
          // Add a standard grey grid - smaller for better performance
          const gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0x444444);
          scene.add(gridHelper);
          
          // Add ground plane - simple grey
          const planeGeometry = new THREE.PlaneGeometry(50, 50);
          const planeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x303030, 
            roughness: 0.8,
            metalness: 0.2
          });
          const plane = new THREE.Mesh(planeGeometry, planeMaterial);
          plane.rotation.x = -Math.PI / 2;
          plane.receiveShadow = true;
          scene.add(plane);
          
          log('Scene elements created successfully', 'info');
        } catch (error) {
          log(`Error creating scene elements: ${error.message}`, 'error');
          console.error('Scene elements error:', error);
        }
      }
      
      // Initialize physics world with improved error handling
      function initPhysics() {
        log('Initializing physics world...', 'info');
        
        try {
          // Create world with gravity
          world = new CANNON.World();
          world.gravity.set(0, -9.82, 0);
          
          // Create ground plane
          const groundShape = new CANNON.Plane();
          const groundBody = new CANNON.Body({ mass: 0 });
          groundBody.addShape(groundShape);
          groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
          world.addBody(groundBody);
          
          // Add friction to ground
          groundBody.material = new CANNON.Material('groundMaterial');
          
          try {
            const groundContactMaterial = new CANNON.ContactMaterial(
              groundBody.material,
              new CANNON.Material('cockroachMaterial'),
              { friction: 0.5, restitution: 0.3 }
            );
            world.addContactMaterial(groundContactMaterial);
          } catch (e) {
            // If contact material fails, continue anyway
            log("Contact material setup failed, using defaults", 'warn');
          }
          
          log('Physics world initialized successfully', 'info');
        } catch (error) {
          log(`Error initializing physics: ${error.message}`, 'error');
          console.error('Physics initialization error:', error);
        }
      }
      
      // Load cockroach model with improved error handling and visual feedback
      function loadCockroachModel() {
        // Updated paths based on actual file location in assets/models
        const possibleFilenames = [
          'assets/models/American Cockroach.glb',  // Correct path found in the repository
          'assets/models/Oriental cockroach.glb',  // Correct path found in the repository
          './assets/models/American Cockroach.glb',
          './assets/models/Oriental cockroach.glb',
          '../assets/models/American Cockroach.glb',
          '../assets/models/Oriental cockroach.glb',
          'models/American Cockroach.glb',
          'models/american-cockroach.glb',
          'models/cockroach.glb'
        ];
        
        log(`Attempting to load cockroach model... trying ${possibleFilenames.length} possible paths`, 'info');
        
        // Show loading indicator
        const loadingIndicator = document.createElement('div');
        loadingIndicator.innerHTML = 'Loading cockroach model...';
        loadingIndicator.style.position = 'absolute';
        loadingIndicator.style.top = '50%';
        loadingIndicator.style.left = '50%';
        loadingIndicator.style.transform = 'translate(-50%, -50%)';
        loadingIndicator.style.color = '#00FF66';
        loadingIndicator.style.fontFamily = 'Courier New, monospace';
        loadingIndicator.style.fontSize = '20px';
        loadingIndicator.style.textShadow = '0 0 5px #00FF66';
        loadingIndicator.style.zIndex = '1000';
        document.getElementById('game-container').appendChild(loadingIndicator);
        
        // Load manager to handle all load attempts
        const loadManager = new THREE.LoadingManager();
        let modelLoaded = false;
        
        // Try each filename in sequence
        function tryNextModel(index) {
          if (index >= possibleFilenames.length) {
            if (!modelLoaded) {
              log('Failed to load any cockroach model, creating placeholder', 'warn');
              log('Model path attempts: ' + possibleFilenames.join(', '), 'error');
              document.getElementById('game-container').removeChild(loadingIndicator);
              createPlaceholderCockroach();
            }
            return;
          }
          
          const filename = possibleFilenames[index];
          log(`Trying to load: ${filename}`, 'info');
          loadingIndicator.innerHTML = `Loading ${filename.split('/').pop()}`;
          
          // Get absolute URL for debugging
          const absoluteUrl = new URL(filename, window.location.href).href;
          log(`Attempting to load: ${filename} (${absoluteUrl})`, 'info');
          
          const loader = new THREE.GLTFLoader(loadManager);
          loader.load(
            filename,
            function(gltf) {
              log(`SUCCESS! Loaded model from ${filename}`, 'info');
              modelLoaded = true;
              document.getElementById('game-container').removeChild(loadingIndicator);
              
              // Store model
              cockroachModel = gltf.scene;
              // Increased scale for better visibility
              cockroachModel.scale.set(0.3, 0.3, 0.3);
              cockroachModel.position.set(0, 0.2, 0); // Raised position slightly
              
              // Make sure model casts shadows
              cockroachModel.traverse(function (child) {
                if (child.isMesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                  // Add slight emission to make it more visible in the dark
                  if (child.material) {
                    child.material.emissive = new THREE.Color(0x222222);
                  }
                }
              });
              
              scene.add(cockroachModel);
              
              // Create physics body
              createCockroachPhysics();
              
              // Update cockroach for rendering
              updateCockroach();
              
              log('Cockroach model added to scene', 'info');
            },
            function(xhr) {
              // Update loading progress
              if (xhr.lengthComputable) {
                const percentComplete = Math.round(xhr.loaded / xhr.total * 100);
                loadingIndicator.innerHTML = `Loading ${filename.split('/').pop()}: ${percentComplete}%`;
              }
            },
            function(error) {
              log(`Failed to load ${filename}: ${error.message}`, 'error');
              console.error(`Model load error for ${filename}:`, error);
              // Short delay before trying next path to avoid rate-limiting
              setTimeout(() => tryNextModel(index + 1), 100);
            }
          );
        }
        
        // Start trying models
        tryNextModel(0);
      }
      
      // Create placeholder cockroach when model loading fails
      function createPlaceholderCockroach() {
        log('Creating placeholder cockroach geometry', 'info');
        try {
          // Create a simple cockroach shape using basic geometries
          const cockroachGroup = new THREE.Group();
          
          // Body - elongated ellipsoid
          const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 12);
          bodyGeometry.scale(1, 0.4, 2);
          const bodyMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x663300, 
            roughness: 0.7,
            metalness: 0.3
          });
          const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
          cockroachGroup.add(body);
          
          // Head
          const headGeometry = new THREE.SphereGeometry(0.2, 16, 12);
          const headMaterial = new THREE.MeshStandardMaterial({ color: 0x663300 });
          const head = new THREE.Mesh(headGeometry, headMaterial);
          head.position.z = 0.7;
          head.position.y = 0.1;
          cockroachGroup.add(head);
          
          // Legs
          const legMaterial = new THREE.MeshStandardMaterial({ color: 0x663300 });
          for (let i = 0; i < 6; i++) {
            // Create a leg (curved cylinder)
            const legGeometry = new THREE.CylinderGeometry(0.05, 0.03, 0.7);
            // Bend it by manipulating vertices
            const leg = new THREE.Mesh(legGeometry, legMaterial);
            
            // Position legs evenly along body
            const side = i % 2 === 0 ? 1 : -1;
            const offset = Math.floor(i / 2) - 1;
            leg.position.set(side * 0.6, 0, offset * 0.5);
            leg.rotation.x = Math.PI / 2;
            leg.rotation.z = side * Math.PI / 4;
            
            cockroachGroup.add(leg);
          }
          
          // Antennae
          for (let i = 0; i < 2; i++) {
            const antennaGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.5);
            const antenna = new THREE.Mesh(antennaGeometry, legMaterial);
            const side = i % 2 === 0 ? 1 : -1;
            antenna.position.set(side * 0.1, 0.2, 0.8);
            antenna.rotation.x = -Math.PI / 4;
            antenna.rotation.y = side * Math.PI / 8;
            cockroachGroup.add(antenna);
          }
          
          // Make all parts cast shadows
          cockroachGroup.traverse(function(child) {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          
          // Set position and add to scene
          cockroachGroup.position.set(0, 0.3, 0);
          cockroachModel = cockroachGroup;
          scene.add(cockroachModel);
          
          // Create physics body
          createCockroachPhysics();
          
          log('Placeholder cockroach created', 'info');
        } catch (error) {
          log(`Error creating placeholder: ${error.message}`, 'error');
          console.error('Error creating placeholder:', error);
        }
      }
      
      // Create cockroach physics body
      function createCockroachPhysics() {
        if (world && cockroachModel) {
          log('Creating cockroach physics body...', 'info');
          
          try {
            // Create a simple box shape for physics
            const shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.2, 1));
            
            // Create body with mass (non-zero for dynamic object)
            cockroachBody = new CANNON.Body({
              mass: 1,
              position: new CANNON.Vec3(
                cockroachModel.position.x, 
                cockroachModel.position.y, 
                cockroachModel.position.z
              ),
              shape: shape,
              linearDamping: 0.5,  // Add damping to prevent excessive sliding
              angularDamping: 0.8  // Prevent excessive rotation
            });
            
            // Add to world
            world.addBody(cockroachBody);
            log('Physics body created successfully', 'info');
          } catch (error) {
            log(`Error creating physics body: ${error.message}`, 'error');
            console.error('Physics body creation error:', error);
          }
        } else {
          log('Cannot create physics body: world or model missing', 'error');
        }
      }
      
      // Enhanced input handlers for better responsiveness
      function setupInputHandlers() {
        // Reset key states to avoid conflicts with global declaration
        keys = {
          forward: false,
          backward: false,
          left: false,
          right: false,
          jump: false
        };
        
        // Track pressed keys with keyCode fallbacks for maximum compatibility
        const keyCodes = {
          // Forward
          87: 'forward',    // W
          38: 'forward',    // Arrow Up
          // Backward
          83: 'backward',   // S
          40: 'backward',   // Arrow Down
          // Left
          65: 'left',       // A
          37: 'left',       // Arrow Left
          // Right
          68: 'right',      // D
          39: 'right',      // Arrow Right
          // Jump
          32: 'jump'        // Space
        };
        
        // Event handler - keydown with maximum compatibility
        window.addEventListener('keydown', function(event) {
          // Prevent default for arrow keys and space
          if ([32, 37, 38, 39, 40].includes(event.keyCode)) {
            event.preventDefault();
          }
          
          // Handle through keyCode (most compatible approach)
          const action = keyCodes[event.keyCode];
          if (action && !keys[action]) {
            keys[action] = true;
            // Force immediate movement update for responsiveness
            updateCockroach();
            
            // Only log if this is the first key pressed
            if (!keys.forward && !keys.backward && !keys.left && !keys.right && !keys.jump) {
              log(`Key pressed: ${event.code || event.keyCode}`, 'input');
            }
          }
          
          // Toggle debug mode (T key = 84)
          if (event.keyCode === 84) {
            debugMode = !debugMode;
            if (debugMode) {
              orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
              log('Debug mode enabled (orbit controls)', 'info');
            } else {
              if (orbitControls) {
                orbitControls.dispose();
                orbitControls = null;
              }
              log('Debug mode disabled', 'info');
            }
          }
        });
        
        // Event handler - keyup with similar compatibility approach
        window.addEventListener('keyup', function(event) {
          // Handle through keyCode (most compatible approach)
          const action = keyCodes[event.keyCode];
          if (action) {
            // Only reset non-jump keys - jump is handled by animation
            if (action !== 'jump' || !isJumping) {
              keys[action] = false;
            }
          }
        });
        
        // Add click handler to ensure focus
        const gameContainer = document.getElementById('game-container');
        gameContainer.addEventListener('click', function() {
          log('Game area clicked, ensuring focus', 'info');
          // Add visible indicator for keyboard focus
          gameContainer.style.outline = '2px solid #888888';
          setTimeout(() => {
            gameContainer.style.outline = 'none';
          }, 500);
        });
        
        // Add touch controls for mobile/tablet support
        addTouchControls();
        
        log('Enhanced input handlers set up with cross-browser compatibility', 'info');
      }
      
      // Add touch controls for mobile devices
      function addTouchControls() {
        const container = document.getElementById('game-container');
        
        // Create touch overlay
        const touchControls = document.createElement('div');
        touchControls.id = 'touch-controls';
        touchControls.style.position = 'fixed';
        touchControls.style.bottom = '20px';
        touchControls.style.left = '50%';
        touchControls.style.transform = 'translateX(-50%)';
        touchControls.style.display = 'flex';
        touchControls.style.flexWrap = 'wrap';
        touchControls.style.justifyContent = 'center';
        touchControls.style.gap = '5px';
        touchControls.style.zIndex = '1000';
        touchControls.style.maxWidth = '100%';
        touchControls.style.padding = '5px';
                // Create touch buttons with simple style but improved responsiveness
        const createButton = (text, key) => {
          const btn = document.createElement('button');
          btn.textContent = text;
          btn.style.backgroundColor = 'rgba(80, 80, 80, 0.7)';
          btn.style.color = '#ffffff';
          btn.style.border = '1px solid #888888';
          btn.style.borderRadius = '5px';
          btn.style.padding = '10px';
          btn.style.margin = '3px';
          btn.style.fontSize = '20px';
          btn.style.fontWeight = 'bold';
          // Responsive button size based on screen width
          const buttonSize = Math.min(70, window.innerWidth / 6) + 'px';
          btn.style.width = buttonSize;
          btn.style.height = buttonSize;
          btn.style.touchAction = 'manipulation';
          btn.style.fontFamily = 'Arial, sans-serif';
          btn.style.userSelect = 'none'; // Prevent text selection
          
          // Touch/mouse events with immediate update
          btn.addEventListener('touchstart', (e) => { 
            e.preventDefault();
            keys[key] = true; 
            updateCockroach(); // Immediate update
            btn.style.backgroundColor = 'rgba(120, 120, 120, 0.9)';
          });
          btn.addEventListener('touchend', () => { 
            keys[key] = false; 
            btn.style.backgroundColor = 'rgba(80, 80, 80, 0.7)';
          });
          btn.addEventListener('mousedown', () => { 
            keys[key] = true; 
            updateCockroach(); // Immediate update
            btn.style.backgroundColor = 'rgba(120, 120, 120, 0.9)';
          });
          btn.addEventListener('mouseup', () => { 
            keys[key] = false; 
            btn.style.backgroundColor = 'rgba(80, 80, 80, 0.7)';
          });
          btn.addEventListener('mouseleave', () => {
            if (keys[key]) {
              keys[key] = false;
              btn.style.backgroundColor = 'rgba(80, 80, 80, 0.7)';
            }
          });
          
          return btn;
        };
        
        // Add directional buttons
        touchControls.appendChild(createButton('↑', 'forward'));
        touchControls.appendChild(createButton('←', 'left'));
        touchControls.appendChild(createButton('↓', 'backward'));
        touchControls.appendChild(createButton('→', 'right'));
        touchControls.appendChild(createButton('⯅', 'jump'));
        
        // Add to container
        container.appendChild(touchControls);
      }
      
      // SIMPLE and DIRECT cockroach movement with no complex timing logic
      function updateCockroach() {
        if (!cockroachModel) return;
        
        // MOVEMENT PARAMETERS - very fast, fixed speed
        const MOVE_SPEED = 0.3; // Units per frame - fast enough to see
        const ROTATE_SPEED = 0.1; // Radians per frame
        
        // Track if any movement occurred
        let moved = false;
        
        // FORWARD MOVEMENT (W key / Up arrow)
        if (keys.forward) {
          // Move forward in the direction the cockroach is facing
          cockroachModel.translateZ(MOVE_SPEED);
          moved = true;
        }
        
        // BACKWARD MOVEMENT (S key / Down arrow)
        if (keys.backward) {
          cockroachModel.translateZ(-MOVE_SPEED);
          moved = true;
        }
        
        // LEFT ROTATION (A key / Left arrow)
        if (keys.left) {
          cockroachModel.rotation.y += ROTATE_SPEED;
          moved = true;
        }
        
        // RIGHT ROTATION (D key / Right arrow)
        if (keys.right) {
          cockroachModel.rotation.y -= ROTATE_SPEED;
          moved = true;
        }
        
        // JUMPING (Spacebar)
        if (keys.jump && !isJumping) {
          isJumping = true;
          jumpTime = 0;
          jumpHeight = cockroachModel.position.y;
        }
        
        // Simple jumping animation
        if (isJumping) {
          jumpTime += 0.1;
          cockroachModel.position.y = jumpHeight + Math.sin(jumpTime) * 1.5;
          
          // End jump at end of cycle
          if (jumpTime >= Math.PI) {
            isJumping = false;
            cockroachModel.position.y = jumpHeight;
          }
          
          moved = true;
        }
        
        // BOUNDARY LIMITS
        const maxBounds = 20;
        cockroachModel.position.x = Math.max(-maxBounds, Math.min(maxBounds, cockroachModel.position.x));
        cockroachModel.position.z = Math.max(-maxBounds, Math.min(maxBounds, cockroachModel.position.z));
        
        // Keep above ground
        if (cockroachModel.position.y < 0.2) {
          cockroachModel.position.y = 0.2;
        }
        
        // Update physics if needed
        if (moved && cockroachBody) {
          cockroachBody.position.copy(cockroachModel.position);
          cockroachBody.quaternion.copy(cockroachModel.quaternion);
          
          // Log occasionally
          if (frameCount % 60 === 0) {
            console.log(`Position: ${cockroachModel.position.x.toFixed(1)}, ${cockroachModel.position.y.toFixed(1)}, ${cockroachModel.position.z.toFixed(1)}`);
          }
        }
        
        return moved;
      }
      
      // Frame count is defined in global variables at the top
      
      // Notify parent window of significant movement
      function notifyParentOfMovement() {
        try {
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({
              type: 'cockroach-moved',
              position: {
                x: cockroachModel.position.x,
                y: cockroachModel.position.y,
                z: cockroachModel.position.z
              }
            }, '*');
          }
        } catch (e) {
          // Ignore cross-origin errors
        }
      }
      
      // Jump state is tracked in global variables
      // initialized at the top of the script
      
      // Update camera to follow cockroach with smooth lerping
      function updateCamera() {
        if (!camera || !cockroachModel) return;
        
        // Set camera position based on cockroach
        const distance = 5; // Distance behind cockroach
        const height = 3;   // Height above cockroach
        
        // Calculate target position
        const targetX = cockroachModel.position.x - Math.sin(cockroachModel.rotation.y) * distance;
        const targetZ = cockroachModel.position.z - Math.cos(cockroachModel.rotation.y) * distance;
        const targetY = cockroachModel.position.y + height;
        
        // Smooth lerp camera position (gentle following)
        camera.position.x = camera.position.x + (targetX - camera.position.x) * 0.1;
        camera.position.z = camera.position.z + (targetZ - camera.position.z) * 0.1;
        camera.position.y = camera.position.y + (targetY - camera.position.y) * 0.1;
        
        // Look at cockroach
        camera.lookAt(cockroachModel.position);
      }
      
      // SIMPLE animation loop - no complex timing logic
      function animate() {
        requestAnimationFrame(animate);
        
        try {
          // Increment frame counter
          frameCount++;
          
          // Simple physics update if needed
          if (world) {
            world.step(1/60);
          }
          
          // Update debug controls if active
          if (debugMode && orbitControls) {
            orbitControls.update();
          }
          
          // Update cockroach position with simple movement
          updateCockroach();
          
          // Update camera
          updateCamera();
          
          // Render
          if (renderer && scene && camera) {
            renderer.render(scene, camera);
          }
        } catch (error) {
          console.error('Animation error:', error);
        }
      }
      
      // Game will initialize when window loads through the onload handler
      
      // Listen for messages from parent window
      window.addEventListener('message', function(event) {
        if (event.data && event.data.action) {
          log(`Received message from parent: ${event.data.action}`);
          
          switch(event.data.action) {
            case 'focus':
              // Focus this window
              window.focus();
              log('Window focused');
              break;
            case 'pause':
              // Pause game logic
              isRunning = false;
              log('Game paused');
              break;
            case 'resume':
              // Resume game logic
              isRunning = true;
              log('Game resumed');
              break;
            case 'keypress':
              // Simulate a keypress from parent
              log(`Received keypress: ${event.data.key}`);
              break;
          }
        }
      });
      
      // Tell parent window we're loaded
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({ type: 'game-loaded' }, '*');
        log('Sent loaded message to parent');
      }
      
      // Add click handler to ensure focus
      document.addEventListener('click', function() {
        log('Game area clicked, ensuring focus');
        window.focus();
      });
      
      // Add a visible message to click for controls
      const clickMessage = document.createElement('div');
      clickMessage.style.position = 'fixed';
      clickMessage.style.top = '50%';
      clickMessage.style.left = '50%';
      clickMessage.style.transform = 'translate(-50%, -50%)';
      clickMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      clickMessage.style.color = '#00FF66';
      clickMessage.style.padding = '20px';
      clickMessage.style.borderRadius = '10px';
      clickMessage.style.fontFamily = 'monospace';
      clickMessage.style.zIndex = '2000';
      clickMessage.style.textAlign = 'center';
      clickMessage.style.boxShadow = '0 0 20px #9333EA';
      clickMessage.style.cursor = 'pointer';
      clickMessage.innerHTML = '<h2>Click to Enable Controls</h2><p>Click anywhere in this area to enable keyboard controls</p>';
      document.body.appendChild(clickMessage);
      
      // Make message clickable to dismiss
      clickMessage.addEventListener('click', function() {
        window.focus();
        if (clickMessage.parentNode) {
          clickMessage.parentNode.removeChild(clickMessage);
        }
      });
      
      // Remove message after a click anywhere
      document.addEventListener('click', function removeClickMessage() {
        if (clickMessage.parentNode) {
          clickMessage.parentNode.removeChild(clickMessage);
        }
        document.removeEventListener('click', removeClickMessage);
      });
    })();
  </script>
</body>
</html>
