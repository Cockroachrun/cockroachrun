<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Cockroach Run - Ultimate Test</title>
  <!-- Load Three.js libraries from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
  <!-- Load Cannon.js physics engine -->
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background-color: #1a1a1a;
      color: #ffffff;
    }
    
    #game-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000000;
    }
    
    /* Debug panel - hidden by default */
    #debug-info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      width: 600px;
      max-width: calc(100% - 20px);
      height: 150px;
      max-height: 25vh;
      background-color: rgba(0, 0, 0, 0.7);
      color: #00ff00;
      border: 1px solid #00ff00;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
      padding: 5px;
      z-index: 100;
      display: none; /* Hidden by default */
    }
    
    #position-display {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.5);
      color: #ffffff;
      padding: 5px;
      font-family: monospace;
      font-size: 12px;
      z-index: 100;
      display: none; /* Hidden by default */
    }
    
    /* Orange controls toggle button */
    #controls-toggle {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      background-color: #FF8000;
      color: white;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      z-index: 1000;
      font-size: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      border: none;
    }
    
    /* Controls panel - hidden by default */
    #controls-info {
      position: absolute;
      top: 60px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.85);
      color: #00ff00;
      border: 1px solid #00ff00;
      padding: 15px;
      font-family: monospace;
      font-size: 14px;
      z-index: 100;
      display: none;
      border-radius: 5px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
      max-width: 300px;
    }
    
    /* Settings menu */
    #settings-menu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.9);
      color: white;
      border: 1px solid #00ff00;
      padding: 20px;
      z-index: 2000;
      width: 80%;
      max-width: 500px;
      border-radius: 5px;
      display: none;
    }
    
    .settings-row {
      display: flex;
      justify-content: space-between;
      margin: 10px 0;
      align-items: center;
    }
    
    .settings-row button, 
    #settings-menu button {
      background-color: #333;
      color: white;
      border: 1px solid #555;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .settings-row button:hover,
    #settings-menu button:hover {
      background-color: #444;
    }
    
    #loading-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.7);
      color: #ffffff;
      padding: 20px;
      border-radius: 5px;
      font-family: sans-serif;
      z-index: 1000;
    }
    
    /* Touch controls style - hidden by default */
    #touch-controls {
      display: none;
    }
    
    #touch-controls button {
      font-size: 24px;
      min-width: 60px;
      height: 60px;
      margin: 5px;
      padding: 10px;
      user-select: none;
      -webkit-user-select: none;
      background-color: rgba(80, 80, 80, 0.5);
      color: white;
      border: 1px solid #555;
      border-radius: 5px;
    }
    
    /* More visible focus for keyboard navigation */
    #game-container:focus {
      outline: 3px solid #00ff00;
    }
    
    @media (max-width: 768px) {
      #debug-info {
        width: 90%;
        font-size: 10px;
      }
      
      #controls-info {
        font-size: 12px;
      }
      
      #touch-controls button {
        font-size: 20px;
        min-width: 50px;
        height: 50px;
      }
    }
  </style>
</head>
<body>
  <div id="game-container" tabindex="0"><!-- Three.js will render here --></div>
  <div id="debug-info"></div>
  <div id="position-display"></div>
  
  <!-- Controls toggle button (orange icon) -->
  <button id="controls-toggle">?</button>
  
  <!-- Controls info panel -->
  <div id="controls-info">
    <h3 style="margin-top: 0; color: #FF8000;">Controls:</h3>
    <p>W/Up Arrow - Move Forward</p>
    <p>S/Down Arrow - Move Backward</p>
    <p>A/Left Arrow - Rotate Left</p>
    <p>D/Right Arrow - Rotate Right</p>
    <p>Space - Jump</p>
    <p>ESC - Settings Menu</p>
    <p>T - Toggle Debug Camera</p>
  </div>
  
  <!-- Settings menu (appears when ESC is pressed) -->
  <div id="settings-menu">
    <h2 style="text-align: center; margin-top: 0; color: #FF8000;">Settings</h2>
    
    <div class="settings-row">
      <label for="touch-controls-toggle">Touch Controls:</label>
      <button id="touch-controls-toggle">Show</button>
    </div>
    
    <div class="settings-row">
      <label for="debug-toggle">Debug Info:</label>
      <button id="debug-toggle">Show</button>
    </div>
    
    <div class="settings-row">
      <label for="music-toggle">Music:</label>
      <button id="music-toggle">On</button>
    </div>
    
    <div class="settings-row">
      <label for="sfx-toggle">Sound Effects:</label>
      <button id="sfx-toggle">On</button>
    </div>
    
    <div class="settings-row" style="justify-content: center; margin-top: 20px;">
      <button id="close-settings">Close</button>
    </div>
  </div>
  
  <div id="loading-indicator" style="display: none;"></div>
  
  <script>
    // Immediately executing function to avoid global namespace pollution
    (function() {
      // Global variables
      let scene, camera, renderer;
      let world, cockroachModel, cockroachBody;
      let clock, controls;
      let keys = {};
      let isJumping = false;
      let jumpTime = 0;
      let jumpHeight = 0;
      let debugMode = false;
      let frameCount = 0;
      let orbitControls = null;
      
      // Enhanced log with color-coded messages and categories
      function log(message, type = 'info') {
        const debugInfo = document.getElementById('debug-info');
        if (debugInfo) {
          const timestamp = new Date().toISOString().substr(11, 8);
          const logEntry = document.createElement('div');
          
          // Color code by type
          let color = '#00FF66'; // Default cyberpunk green
          switch(type) {
            case 'error': color = '#FF3366'; break; // Red for errors
            case 'warn': color = '#FFCC00'; break;  // Yellow for warnings
            case 'move': color = '#9333EA'; break;  // Purple for movement
            case 'input': color = '#00CCFF'; break; // Blue for input events
          }
          
          // Style with cyberpunk flair
          logEntry.innerHTML = `<span style="color:#666666">[${timestamp}]</span> <span style="color:${color}">${message}</span>`;
          debugInfo.appendChild(logEntry);
          
          // Scroll to bottom
          debugInfo.scrollTop = debugInfo.scrollHeight;
          
          // Limit entries
          while (debugInfo.childElementCount > 50) {
            debugInfo.removeChild(debugInfo.firstChild);
          }
        }
        console.log(`[${type.toUpperCase()}] ${message}`);
      }
      
      // Initialize the game when the DOM is loaded
      window.onload = function() {
        init();
      };
      
      // Get URL parameters (for mode and character selection)
      const urlParams = new URLSearchParams(window.location.search);
      const selectedMode = urlParams.get('mode') || 'free-world';
      const selectedCharacter = urlParams.get('character') || 'default-roach';
      
      log(`Selected mode: ${selectedMode}, character: ${selectedCharacter}`);
      
      // Main game variables
      // Canvas is managed directly by renderer
      
      // Input state
      keys = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        jump: false
      };
      
      // Initialize the game and set up UI controls
      function init() {
        log('========================================', 'info');
        log('COCKROACH RUN - GAME INITIALIZING', 'info');
        log('========================================', 'info');
        
        // Hide loading indicator, we don't need it
        document.getElementById('loading-indicator').style.display = 'none';
        
        // Set up controls toggle button
        document.getElementById('controls-toggle').addEventListener('click', function() {
          const controlsPanel = document.getElementById('controls-info');
          controlsPanel.style.display = controlsPanel.style.display === 'none' ? 'block' : 'none';
        });
        
        // Set up settings menu and ESC key handling
        const settingsMenu = document.getElementById('settings-menu');
        const closeSettings = document.getElementById('close-settings');
        
        // ESC key to open/close settings
        window.addEventListener('keydown', function(e) {
          if (e.key === 'Escape' || e.keyCode === 27) {
            if (settingsMenu.style.display === 'block') {
              settingsMenu.style.display = 'none';
              resumeGame();
            } else {
              settingsMenu.style.display = 'block';
              pauseGame();
            }
          }
        });
        
        // Close button for settings
        closeSettings.addEventListener('click', function() {
          settingsMenu.style.display = 'none';
          resumeGame();
        });
        
        // Debug toggle button
        document.getElementById('debug-toggle').addEventListener('click', function() {
          const debugInfo = document.getElementById('debug-info');
          const currentDisplay = debugInfo.style.display === 'block';
          
          debugInfo.style.display = currentDisplay ? 'none' : 'block';
          this.textContent = currentDisplay ? 'Show' : 'Hide';
        });
        
        // Music toggle button
        document.getElementById('music-toggle').addEventListener('click', function() {
          // Try to access parent window's audio manager
          try {
            const audioManager = window.parent.AudioManager;
            if (audioManager) {
              if (audioManager.isMuted) {
                audioManager.unmute();
                this.textContent = 'On';
              } else {
                audioManager.mute();
                this.textContent = 'Off';
              }
            } else {
              log('AudioManager not found in parent window', 'warn');
            }
          } catch (e) {
            log('Cannot access parent audio: ' + e.message, 'error');
          }
        });
        
        // Sound effects toggle (same as music for now)
        document.getElementById('sfx-toggle').addEventListener('click', function() {
          const musicToggle = document.getElementById('music-toggle');
          musicToggle.click(); // Reuse music toggle functionality
          this.textContent = musicToggle.textContent;
        });
        
        // Game state variables
        let gamePaused = false;
        
        // Function to pause game
        function pauseGame() {
          gamePaused = true;
          log('Game paused', 'info');
        }
        
        // Function to resume game
        function resumeGame() {
          gamePaused = false;
          log('Game resumed', 'info');
        }
        
        // Setup initial UI states
        document.getElementById('debug-info').style.display = 'none';
        document.getElementById('debug-toggle').textContent = 'Show';
        
        // Start music
        try {
          if (window.parent.AudioManager) {
            window.parent.AudioManager.unmute();
            if (window.parent.AudioManager.gameMusic) {
              window.parent.AudioManager.gameMusic.play();
              log('Game music started', 'info');
            }
          }
        } catch (e) {
          log('Error initializing audio: ' + e.message, 'warn');
        }
        
        // Setup touch controls based on device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
          const touchControlsToggle = document.getElementById('touch-controls-toggle');
          if (touchControlsToggle) {
            touchControlsToggle.textContent = 'Hide';
          }
        }
        
        try {
          // Log character and mode selection
          log(`Selected mode: ${selectedMode}, character: ${selectedCharacter}`, 'info');
          
          // Create clock for timing
          clock = new THREE.Clock();
          
          // Reset key states
          keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false
          };
          
          // Set jump variables
          isJumping = false;
          jumpTime = 0;
          jumpHeight = 0;
          jumpPressed = false;
          canJump = true;
          
          // Other initialization variables
          debugMode = false;
          frameCount = 0;
          
          log('Setting up Three.js...', 'info');
          
          // Create renderer directly here to avoid reassignment issues
          const gameContainer = document.getElementById('game-container');
          gameContainer.innerHTML = ''; // Clear any previous content
          
          // Enhanced window resize handling for mobile
          function onWindowResize() {
            if (camera && renderer) {
              // Get actual viewport dimensions
              const width = window.innerWidth;
              const height = window.innerHeight;
              
              // Update camera and renderer
              camera.aspect = width / height;
              camera.updateProjectionMatrix();
              renderer.setSize(width, height, true); // true for updateStyle
            }
          }
          window.addEventListener('resize', onWindowResize, false);
          
          // Create and configure renderer
          try {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            gameContainer.appendChild(renderer.domElement);
            log('Renderer created successfully', 'info');
          } catch (e) {
            log('ERROR creating renderer: ' + e.message, 'error');
            console.error('Renderer error:', e);
          }
          
          // Setup scene with the simplest possible environment
          function setupScene() {
            log('Setting up scene...', 'info');
            
            try {
              scene = new THREE.Scene();
              scene.background = new THREE.Color(0x333333); // Medium grey background
              
              // Create camera
              camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
              camera.position.set(0, 3, 5); // Positioned behind cockroach
              
              // Add lights
              const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
              scene.add(ambientLight);
              
              const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
              directionalLight.position.set(5, 10, 7.5);
              directionalLight.castShadow = true;
              scene.add(directionalLight);
              
              // Set up shadow properties
              directionalLight.shadow.mapSize.width = 1024;
              directionalLight.shadow.mapSize.height = 1024;
              directionalLight.shadow.camera.near = 0.5;
              directionalLight.shadow.camera.far = 50;
              directionalLight.shadow.bias = -0.001;
              
              // Create ground plane
              const planeGeometry = new THREE.PlaneGeometry(100, 100);
              const planeMaterial = new THREE.MeshStandardMaterial({
                color: 0x808080,
                roughness: 0.7,
                metalness: 0.1,
              });
              const plane = new THREE.Mesh(planeGeometry, planeMaterial);
              plane.rotation.x = -Math.PI / 2; // Rotate to be flat
              plane.receiveShadow = true;
              scene.add(plane);
              
              // Add grid for better visual reference
              const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x444444);
              scene.add(gridHelper);
              
              // Initialize camera position
              camera.position.set(0, 3, 5);
              camera.lookAt(0, 0, 0);
              
              log('Scene setup complete', 'info');
            } catch (e) {
              log('ERROR setting up scene: ' + e.message, 'error');
              console.error('Scene setup error:', e);
            }
          }
          setupScene();
          
          // Initialize physics
          initPhysics();
          
          // Load cockroach model
          loadCockroachModel();
          
          // Setup input handlers
          setupInputHandlers();
          
          // Start animation loop
          animate();
          
          log('Game initialization complete', 'info');
          log('========================================', 'info');
          log('Use WASD or arrow keys to move', 'info');
          log('Press SPACE to jump', 'info');
          log('Press T to toggle debug mode', 'info');
          log('========================================', 'info');
          
          // Inform parent we're loaded
          sendLoadedMessage();
          
          return true;
        } catch (error) {
          log(`CRITICAL ERROR during initialization: ${error.message}`, 'error');
          console.error('Game initialization error:', error);
          return false;
        }
      }
      
      // Send message to parent that game is loaded
      function sendLoadedMessage() {
        try {
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({
              type: 'game-loaded',
              status: 'success'
            }, '*');
            log('Sent loaded message to parent', 'info');
          }
        } catch (e) {
          console.error('Error sending loaded message:', e);
        }
      }
      
      // Initialize more realistic physics world
      function initPhysics() {
        log('Initializing physics world...', 'info');
        
        try {
          // Create world with gravity and damping
          world = new CANNON.World();
          world.gravity.set(0, -9.82, 0); // Earth gravity
          world.defaultContactMaterial.friction = 0.2; // Global friction
          world.allowSleep = true; // Allow objects to sleep when inactive (performance)
          world.solver.iterations = 10; // More accurate physics
          
          // Create ground plane with extra friction to prevent sliding
          const groundShape = new CANNON.Plane();
          const groundBody = new CANNON.Body({ mass: 0 }); // Static body
          groundBody.addShape(groundShape);
          groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
          world.addBody(groundBody);
          
          // Create materials with proper physical properties
          try {
            // Ground material (high friction)
            const groundMaterial = new CANNON.Material('groundMaterial');
            groundBody.material = groundMaterial;
            
            // Cockroach material (good grip for climbing)
            const cockroachMaterial = new CANNON.Material('cockroachMaterial');
            
            // Contact behavior between materials
            const contactMaterial = new CANNON.ContactMaterial(
              groundMaterial,
              cockroachMaterial,
              { 
                friction: 0.8, // High friction for better grip
                restitution: 0.2, // Low bounce
                contactEquationStiffness: 1e8, // Firm contact
                contactEquationRelaxation: 3 // Stable contact
              }
            );
            world.addContactMaterial(contactMaterial);
            
            log('Physics materials configured for realistic movement', 'info');
          } catch (e) {
            log("Advanced physics setup failed, using basic settings", 'warn');
            console.warn('Physics setup issue:', e);
          }
          
          log('Physics world initialized successfully', 'info');
        } catch (error) {
          log(`Error initializing physics: ${error.message}`, 'error');
          console.error('Physics initialization error:', error);
        }
      }
      
      // Load cockroach model with improved error handling and visual feedback
      function loadCockroachModel() {
        // Updated paths based on actual file location in assets/models
        const possibleFilenames = [
          'assets/models/American Cockroach.glb',  // Correct path found in the repository
          'assets/models/Oriental cockroach.glb',  // Correct path found in the repository
          './assets/models/American Cockroach.glb',
          './assets/models/Oriental cockroach.glb',
          '../assets/models/American Cockroach.glb',
          '../assets/models/Oriental cockroach.glb',
          'models/American Cockroach.glb',
          'models/american-cockroach.glb',
          'models/cockroach.glb'
        ];
        
        log(`Attempting to load cockroach model... trying ${possibleFilenames.length} possible paths`, 'info');
        
        // Show loading indicator
        const loadingIndicator = document.createElement('div');
        loadingIndicator.innerHTML = 'Loading cockroach model...';
        loadingIndicator.style.position = 'absolute';
        loadingIndicator.style.top = '50%';
        loadingIndicator.style.left = '50%';
        loadingIndicator.style.transform = 'translate(-50%, -50%)';
        loadingIndicator.style.color = '#00FF66';
        loadingIndicator.style.fontFamily = 'Courier New, monospace';
        loadingIndicator.style.fontSize = '20px';
        loadingIndicator.style.textShadow = '0 0 5px #00FF66';
        loadingIndicator.style.zIndex = '1000';
        document.getElementById('game-container').appendChild(loadingIndicator);
        
        // Load manager to handle all load attempts
        const loadManager = new THREE.LoadingManager();
        let modelLoaded = false;
        
        // Try each filename in sequence
        function tryNextModel(index) {
          if (index >= possibleFilenames.length) {
            if (!modelLoaded) {
              log('Failed to load any cockroach model, creating placeholder', 'warn');
              log('Model path attempts: ' + possibleFilenames.join(', '), 'error');
              document.getElementById('game-container').removeChild(loadingIndicator);
              createPlaceholderCockroach();
            }
            return;
          }
          
          const filename = possibleFilenames[index];
          log(`Trying to load: ${filename}`, 'info');
          loadingIndicator.innerHTML = `Loading ${filename.split('/').pop()}`;
          
          // Get absolute URL for debugging
          const absoluteUrl = new URL(filename, window.location.href).href;
          log(`Attempting to load: ${filename} (${absoluteUrl})`, 'info');
          
          const loader = new THREE.GLTFLoader(loadManager);
          loader.load(
            filename,
            function(gltf) {
              log(`SUCCESS! Loaded model from ${filename}`, 'info');
              modelLoaded = true;
              document.getElementById('game-container').removeChild(loadingIndicator);
              
              // Store model
              cockroachModel = gltf.scene;
              // Increased scale for better visibility
              cockroachModel.scale.set(0.3, 0.3, 0.3);
              cockroachModel.position.set(0, 0.2, 0); // Raised position slightly
              
              // Make sure model casts shadows
              cockroachModel.traverse(function (child) {
                if (child.isMesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                  // Add slight emission to make it more visible in the dark
                  if (child.material) {
                    child.material.emissive = new THREE.Color(0x222222);
                  }
                }
              });
              
              scene.add(cockroachModel);
              
              // Create physics body
              createCockroachPhysics();
              
              // Update cockroach for rendering
              updateCockroach();
              
              log('Cockroach model added to scene', 'info');
            },
            function(xhr) {
              // Update loading progress
              if (xhr.lengthComputable) {
                const percentComplete = Math.round(xhr.loaded / xhr.total * 100);
                loadingIndicator.innerHTML = `Loading ${filename.split('/').pop()}: ${percentComplete}%`;
              }
            },
            function(error) {
              log(`Failed to load ${filename}: ${error.message}`, 'error');
              console.error(`Model load error for ${filename}:`, error);
              // Short delay before trying next path to avoid rate-limiting
              setTimeout(() => tryNextModel(index + 1), 100);
            }
          );
        }
        
        // Start trying models
        tryNextModel(0);
      }
      
      // Create placeholder cockroach when model loading fails
      function createPlaceholderCockroach() {
        log('Creating placeholder cockroach geometry', 'info');
        try {
          // Create a simple cockroach shape using basic geometries
          const cockroachGroup = new THREE.Group();
          
          // Body - elongated ellipsoid
          const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 12);
          bodyGeometry.scale(1, 0.4, 2);
          const bodyMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x663300, 
            roughness: 0.7,
            metalness: 0.3
          });
          const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
          cockroachGroup.add(body);
          
          // Head
          const headGeometry = new THREE.SphereGeometry(0.2, 16, 12);
          const headMaterial = new THREE.MeshStandardMaterial({ color: 0x663300 });
          const head = new THREE.Mesh(headGeometry, headMaterial);
          head.position.z = 0.7;
          head.position.y = 0.1;
          cockroachGroup.add(head);
          
          // Legs
          const legMaterial = new THREE.MeshStandardMaterial({ color: 0x663300 });
          for (let i = 0; i < 6; i++) {
            // Create a leg (curved cylinder)
            const legGeometry = new THREE.CylinderGeometry(0.05, 0.03, 0.7);
            // Bend it by manipulating vertices
            const leg = new THREE.Mesh(legGeometry, legMaterial);
            
            // Position legs evenly along body
            const side = i % 2 === 0 ? 1 : -1;
            const offset = Math.floor(i / 2) - 1;
            leg.position.set(side * 0.6, 0, offset * 0.5);
            leg.rotation.x = Math.PI / 2;
            leg.rotation.z = side * Math.PI / 4;
            
            cockroachGroup.add(leg);
          }
          
          // Antennae
          for (let i = 0; i < 2; i++) {
            const antennaGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.5);
            const antenna = new THREE.Mesh(antennaGeometry, legMaterial);
            const side = i % 2 === 0 ? 1 : -1;
            antenna.position.set(side * 0.1, 0.2, 0.8);
            antenna.rotation.x = -Math.PI / 4;
            antenna.rotation.y = side * Math.PI / 8;
            cockroachGroup.add(antenna);
          }
          
          // Make all parts cast shadows
          cockroachGroup.traverse(function(child) {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          
          // Set position and add to scene
          cockroachGroup.position.set(0, 0.3, 0);
          cockroachModel = cockroachGroup;
          scene.add(cockroachModel);
          
          // Create physics body
          createCockroachPhysics();
          
          log('Placeholder cockroach created', 'info');
        } catch (error) {
          log(`Error creating placeholder: ${error.message}`, 'error');
          console.error('Error creating placeholder:', error);
        }
      }
      
      // Create cockroach physics body
      function createCockroachPhysics() {
        if (world && cockroachModel) {
          log('Creating cockroach physics body...', 'info');
          
          try {
            // Create a simple box shape for physics
            const shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.2, 1));
            
            // Create body with mass (non-zero for dynamic object)
            cockroachBody = new CANNON.Body({
              mass: 1,
              position: new CANNON.Vec3(
                cockroachModel.position.x, 
                cockroachModel.position.y, 
                cockroachModel.position.z
              ),
              shape: shape,
              linearDamping: 0.5,  // Add damping to prevent excessive sliding
              angularDamping: 0.8  // Prevent excessive rotation
            });
            
            // Add to world
            world.addBody(cockroachBody);
            log('Physics body created successfully', 'info');
          } catch (error) {
            log(`Error creating physics body: ${error.message}`, 'error');
            console.error('Physics body creation error:', error);
          }
        } else {
          log('Cannot create physics body: world or model missing', 'error');
        }
      }
      
      // Enhanced input handlers for better responsiveness
      function setupInputHandlers() {
        // Reset key states to avoid conflicts with global declaration
        keys = {
          forward: false,
          backward: false,
          left: false,
          right: false,
          jump: false
        };
        
        // Track pressed keys with keyCode fallbacks for maximum compatibility
        const keyCodes = {
          // Forward
          87: 'forward',    // W
          38: 'forward',    // Arrow Up
          // Backward
          83: 'backward',   // S
          40: 'backward',   // Arrow Down
          // Left
          65: 'left',       // A
          37: 'left',       // Arrow Left
          // Right
          68: 'right',      // D
          39: 'right',      // Arrow Right
          // Jump
          32: 'jump'        // Space
        };
        
        // Event handler - keydown with maximum compatibility
        window.addEventListener('keydown', function(event) {
          // Prevent default for arrow keys and space
          if ([32, 37, 38, 39, 40].includes(event.keyCode)) {
            event.preventDefault();
          }
          
          // Handle through keyCode (most compatible approach)
          const action = keyCodes[event.keyCode];
          if (action) {
            // Special handling for jump to prevent continuous jumping
            if (action === 'jump') {
              if (!jumpPressed && canJump) {
                keys.jump = true;
                jumpPressed = true;
                log('Jump key pressed - initiating jump', 'input');
              }
            } else if (!keys[action]) {
              // Normal handling for movement keys
              keys[action] = true;
              
              // Only log if this is a new key
              log(`Key pressed: ${event.code || event.keyCode}`, 'input');
            }
            
            // Force immediate movement update for responsiveness
            updateCockroach();
          }
          
          // Toggle debug mode (T key = 84)
          if (event.keyCode === 84) {
            debugMode = !debugMode;
            if (debugMode) {
              orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
              log('Debug mode enabled (orbit controls)', 'info');
            } else {
              if (orbitControls) {
                orbitControls.dispose();
                orbitControls = null;
              }
              log('Debug mode disabled', 'info');
            }
          }
        });
        
        // Event handler - keyup with similar compatibility approach
        window.addEventListener('keyup', function(event) {
          // Handle through keyCode (most compatible approach)
          const action = keyCodes[event.keyCode];
          if (action) {
            if (action === 'jump') {
              // Reset jump key state and pressed tracking
              keys.jump = false;
              jumpPressed = false;
              log('Jump key released', 'input');
            } else {
              // Normal handling for movement keys
              keys[action] = false;
            }
          }
        });
        
        // Add click handler to ensure focus
        const gameContainer = document.getElementById('game-container');
        gameContainer.addEventListener('click', function() {
          log('Game area clicked, ensuring focus', 'info');
          // Add visible indicator for keyboard focus
          gameContainer.style.outline = '2px solid #888888';
          setTimeout(() => {
            gameContainer.style.outline = 'none';
          }, 500);
        });
        
        // Add touch controls for mobile/tablet support
        addTouchControls();
        
        log('Enhanced input handlers set up with cross-browser compatibility', 'info');
      }
      
      // Add touch controls for mobile devices
      function addTouchControls() {
        const container = document.getElementById('game-container');
        
        // Create touch overlay
        const touchControls = document.createElement('div');
        touchControls.id = 'touch-controls';
        touchControls.style.position = 'fixed';
        touchControls.style.bottom = '20px';
        touchControls.style.left = '50%';
        touchControls.style.transform = 'translateX(-50%)';
        touchControls.style.display = 'none'; // Hidden by default
        touchControls.style.flexWrap = 'wrap';
        touchControls.style.justifyContent = 'center';
        touchControls.style.gap = '5px';
        touchControls.style.zIndex = '1000';
        touchControls.style.maxWidth = '100%';
        touchControls.style.padding = '5px';
        
        // Create touch buttons with simple style but improved responsiveness
        const createButton = (text, key) => {
          const btn = document.createElement('button');
          btn.textContent = text;
          btn.style.backgroundColor = 'rgba(80, 80, 80, 0.7)';
          btn.style.color = '#ffffff';
          btn.style.border = '1px solid #888888';
          btn.style.borderRadius = '5px';
          btn.style.fontSize = '24px';
          btn.style.padding = '15px';
          btn.style.margin = '5px';
          btn.style.minWidth = '60px';
          btn.style.minHeight = '60px';
          btn.style.touchAction = 'manipulation';
          
          // Handle touch events for mobile
          btn.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent zooming
            keys[key] = true;
            log(`Touch control: ${text}`, 'input');
          });
          
          btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys[key] = false;
          });
          
          // Also handle mouse events for testing on desktop
          btn.addEventListener('mousedown', () => {
            keys[key] = true;
          });
          
          btn.addEventListener('mouseup', () => {
            keys[key] = false;
          });
          
          btn.addEventListener('mouseleave', () => {
            keys[key] = false;
          });
          
          return btn;
        };
        
        // Create directional buttons
        const upBtn = createButton('↑', 'forward');
        const downBtn = createButton('↓', 'backward');
        const leftBtn = createButton('←', 'left');
        const rightBtn = createButton('→', 'right');
        
        // Create jump button
        const jumpBtn = createButton('JUMP', 'jump');
        jumpBtn.style.width = '120px';
        
        // Add buttons to container
        touchControls.appendChild(upBtn);
        touchControls.appendChild(document.createElement('br'));
        touchControls.appendChild(leftBtn);
        touchControls.appendChild(downBtn);
        touchControls.appendChild(rightBtn);
        touchControls.appendChild(document.createElement('br'));
        touchControls.appendChild(jumpBtn);
        
        // Add to page
        document.body.appendChild(touchControls);
        
        // Check if mobile and initialize touch button state
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
          // Set initial state for settings button
          document.getElementById('touch-controls-toggle').textContent = 'Hide';
          touchControls.style.display = 'flex';
          log('Mobile device detected - touch controls enabled', 'info');
        } else {
          document.getElementById('touch-controls-toggle').textContent = 'Show';
          log('Desktop detected - touch controls hidden by default', 'info');
        }
        
        // Set up toggle button functionality
        document.getElementById('touch-controls-toggle').addEventListener('click', function() {
          if (touchControls.style.display === 'none') {
            touchControls.style.display = 'flex';
            this.textContent = 'Hide';
          } else {
            touchControls.style.display = 'none';
            this.textContent = 'Show';
          }
        });
      }
      
      // SIMPLE and DIRECT cockroach movement with no complex timing logic
      function updateCockroach() {
        if (!cockroachModel) return;
        
        // MOVEMENT PARAMETERS with realistic physics
        const MOVE_SPEED = 0.25; // Base movement speed
        const ROTATE_SPEED = 0.08; // Base rotation speed
        const ACCELERATION = 0.01; // How quickly the cockroach speeds up
        const DECELERATION = 0.95; // How quickly it slows down (friction)
        const MAX_SPEED = 0.4; // Maximum movement speed
        
        // Keep track of current velocity
        cockroachModel.userData.velocity = cockroachModel.userData.velocity || {
          forward: 0,
          rotation: 0
        }
        
        // Track if any movement occurred
        let moved = false;
        
        // REALISTIC MOVEMENT with acceleration/deceleration
        
        // FORWARD/BACKWARD MOVEMENT with acceleration
        if (keys.forward) {
          // Accelerate forward up to max speed
          cockroachModel.userData.velocity.forward += ACCELERATION;
          if (cockroachModel.userData.velocity.forward > MAX_SPEED) {
            cockroachModel.userData.velocity.forward = MAX_SPEED;
          }
          moved = true;
        } else if (keys.backward) {
          // Accelerate backward up to max speed
          cockroachModel.userData.velocity.forward -= ACCELERATION;
          if (cockroachModel.userData.velocity.forward < -MAX_SPEED * 0.7) { // Cockroaches are slower backward
            cockroachModel.userData.velocity.forward = -MAX_SPEED * 0.7;
          }
          moved = true;
        } else {
          // Decelerate when no forward/backward key is pressed
          cockroachModel.userData.velocity.forward *= DECELERATION;
          
          // Stop completely if very slow (avoid endless tiny movements)
          if (Math.abs(cockroachModel.userData.velocity.forward) < 0.01) {
            cockroachModel.userData.velocity.forward = 0;
          }
        }
        
        // Apply forward/backward movement
        if (cockroachModel.userData.velocity.forward !== 0) {
          cockroachModel.translateZ(cockroachModel.userData.velocity.forward);
          moved = true;
        }
        
        // LEFT/RIGHT ROTATION with momentum
        if (keys.left) {
          // Increase rotation velocity (left)
          cockroachModel.userData.velocity.rotation += ACCELERATION * 2;
          if (cockroachModel.userData.velocity.rotation > ROTATE_SPEED) {
            cockroachModel.userData.velocity.rotation = ROTATE_SPEED;
          }
          moved = true;
        } else if (keys.right) {
          // Increase rotation velocity (right)
          cockroachModel.userData.velocity.rotation -= ACCELERATION * 2;
          if (cockroachModel.userData.velocity.rotation < -ROTATE_SPEED) {
            cockroachModel.userData.velocity.rotation = -ROTATE_SPEED;
          }
          moved = true;
        } else {
          // Decelerate rotation when no left/right key is pressed
          cockroachModel.userData.velocity.rotation *= DECELERATION;
          
          // Stop rotating if very slow
          if (Math.abs(cockroachModel.userData.velocity.rotation) < 0.005) {
            cockroachModel.userData.velocity.rotation = 0;
          }
        }
        
        // Apply rotation
        if (cockroachModel.userData.velocity.rotation !== 0) {
          cockroachModel.rotation.y += cockroachModel.userData.velocity.rotation;
          moved = true;
        }
        
        // Add slight body tilt when turning (more realistic)
        if (cockroachModel.userData.velocity.rotation !== 0) {
          // Lean into turns
          const targetTilt = -cockroachModel.userData.velocity.rotation * 2;
          cockroachModel.rotation.z = targetTilt;
        } else {
          // Return to level when not turning
          cockroachModel.rotation.z *= 0.8;
        }
        
        // JUMPING (Spacebar) with single-press logic and cooldown
        if (keys.jump && !isJumping && canJump) {
          isJumping = true;
          jumpTime = 0;
          jumpHeight = cockroachModel.position.y;
          canJump = false; // Prevent new jumps until this one completes
          keys.jump = false; // Immediately reset jump key to prevent multiple jumps
          console.log('Jump initiated'); // Debug log
        }
        
        // Realistic jumping with acceleration and landing
        if (isJumping) {
          // More realistic jump curve with fast rise and slower fall
          jumpTime += 0.1;
          
          // Calculate jump height using a custom curve for more realistic movement
          let jumpCurve;
          if (jumpTime < Math.PI/2) {
            // Quick upward movement (0 to π/2)
            jumpCurve = Math.sin(jumpTime) * 1.2;
          } else {
            // Slower fall (π/2 to π)
            jumpCurve = Math.sin(jumpTime) * 0.8;
          }
          
          // Apply jump height
          cockroachModel.position.y = jumpHeight + jumpCurve;
          
          // End jump at end of cycle
          if (jumpTime >= Math.PI) {
            isJumping = false;
            cockroachModel.position.y = jumpHeight;
            canJump = true; // Re-enable jumping after landing
            console.log('Jump completed, can jump again'); // Debug log
            
            // Add a slight forward impulse on landing (cockroaches often jump forward)
            if (cockroachModel.userData.velocity.forward >= 0) {
              cockroachModel.userData.velocity.forward += 0.05;
            }
          }
          
          moved = true;
        }
        
        // BOUNDARY LIMITS
        const maxBounds = 20;
        cockroachModel.position.x = Math.max(-maxBounds, Math.min(maxBounds, cockroachModel.position.x));
        cockroachModel.position.z = Math.max(-maxBounds, Math.min(maxBounds, cockroachModel.position.z));
        
        // Keep above ground
        if (cockroachModel.position.y < 0.2) {
          cockroachModel.position.y = 0.2;
        }
        
        // Update physics if needed
        if (moved && cockroachBody) {
          cockroachBody.position.copy(cockroachModel.position);
          cockroachBody.quaternion.copy(cockroachModel.quaternion);
          
          // Log occasionally
          if (frameCount % 60 === 0) {
            console.log(`Position: ${cockroachModel.position.x.toFixed(1)}, ${cockroachModel.position.y.toFixed(1)}, ${cockroachModel.position.z.toFixed(1)}`);
          }
        }
        
        return moved;
      }
      
      // Frame count is defined in global variables at the top
      
      // Notify parent window of significant movement
      function notifyParentOfMovement() {
        try {
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({
              type: 'cockroach-moved',
              position: {
                x: cockroachModel.position.x,
                y: cockroachModel.position.y,
                z: cockroachModel.position.z
              }
            }, '*');
          }
        } catch (e) {
          // Ignore cross-origin errors
        }
      }
      
      // Jump state is tracked in global variables
      // initialized at the top of the script
      
      // Update camera to follow cockroach with improved tracking
      function updateCamera() {
        if (!camera || !cockroachModel) return;
        
        // Camera settings
        const distance = 5;  // Distance behind cockroach
        const height = 3;    // Height above cockroach
        const lookOffset = 2; // Look slightly ahead of cockroach
        
        // Calculate target position behind cockroach
        const targetX = cockroachModel.position.x - Math.sin(cockroachModel.rotation.y) * distance;
        const targetZ = cockroachModel.position.z - Math.cos(cockroachModel.rotation.y) * distance;
        const targetY = cockroachModel.position.y + height;
        
        // Calculate point to look at (slightly ahead of cockroach)
        const lookAtX = cockroachModel.position.x + Math.sin(cockroachModel.rotation.y) * lookOffset;
        const lookAtZ = cockroachModel.position.z + Math.cos(cockroachModel.rotation.y) * lookOffset;
        const lookAtY = cockroachModel.position.y + 0.5; // Slightly above cockroach
        
        // Smooth camera movement based on cockroach velocity
        // Faster follow when cockroach is moving quickly
        const speedFactor = Math.abs(cockroachModel.userData.velocity.forward) * 2;
        const followSpeed = 0.05 + speedFactor * 0.1; // 0.05 to 0.15 based on speed
        
        // Apply smooth camera movement
        camera.position.x += (targetX - camera.position.x) * followSpeed;
        camera.position.z += (targetZ - camera.position.z) * followSpeed;
        camera.position.y += (targetY - camera.position.y) * followSpeed;
        
        // Look ahead of cockroach (makes turns look better)
        camera.lookAt(new THREE.Vector3(lookAtX, lookAtY, lookAtZ));
      }
      
      // SIMPLE animation loop - no complex timing logic
      function animate() {
        requestAnimationFrame(animate);
        
        try {
          // Increment frame counter
          frameCount++;
          
          // Simple physics update if needed
          if (world) {
            world.step(1/60);
          }
          
          // Update debug controls if active
          if (debugMode && orbitControls) {
            orbitControls.update();
          }
          
          // Update cockroach position with simple movement
          updateCockroach();
          
          // Update camera
          updateCamera();
          
          // Render
          if (renderer && scene && camera) {
            renderer.render(scene, camera);
          }
        } catch (error) {
          console.error('Animation error:', error);
        }
      }
      
      // Game will initialize when window loads through the onload handler
      
      // Listen for messages from parent window
      window.addEventListener('message', function(event) {
        if (event.data && event.data.action) {
          log(`Received message from parent: ${event.data.action}`);
          
          switch(event.data.action) {
            case 'focus':
              // Focus this window
              window.focus();
              log('Window focused');
              break;
            case 'pause':
              // Pause game logic
              isRunning = false;
              log('Game paused');
              break;
            case 'resume':
              // Resume game logic
              isRunning = true;
              log('Game resumed');
              break;
            case 'keypress':
              // Simulate a keypress from parent
              log(`Received keypress: ${event.data.key}`);
              break;
          }
        }
      });
      
      // Tell parent window we're loaded
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({ type: 'game-loaded' }, '*');
        log('Sent loaded message to parent');
      }
      
      // Add click handler to ensure focus
      document.addEventListener('click', function() {
        log('Game area clicked, ensuring focus');
        window.focus();
      });
      
      // Add a visible message to click for controls
      const clickMessage = document.createElement('div');
      clickMessage.style.position = 'fixed';
      clickMessage.style.top = '50%';
      clickMessage.style.left = '50%';
      clickMessage.style.transform = 'translate(-50%, -50%)';
      clickMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      clickMessage.style.color = '#00FF66';
      clickMessage.style.padding = '20px';
      clickMessage.style.borderRadius = '10px';
      clickMessage.style.fontFamily = 'monospace';
      clickMessage.style.zIndex = '2000';
      clickMessage.style.textAlign = 'center';
      clickMessage.style.boxShadow = '0 0 20px #9333EA';
      clickMessage.style.cursor = 'pointer';
      clickMessage.innerHTML = '<h2>Click to Enable Controls</h2><p>Click anywhere in this area to enable keyboard controls</p>';
      document.body.appendChild(clickMessage);
      
      // Make message clickable to dismiss
      clickMessage.addEventListener('click', function() {
        window.focus();
        if (clickMessage.parentNode) {
          clickMessage.parentNode.removeChild(clickMessage);
        }
      });
      
      // Remove message after a click anywhere
      document.addEventListener('click', function removeClickMessage() {
        if (clickMessage.parentNode) {
          clickMessage.parentNode.removeChild(clickMessage);
        }
        document.removeEventListener('click', removeClickMessage);
      });
    })();
  </script>
</body>
</html>
