<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cockroach Run - Ultimate Test</title>
  <!-- Load Three.js libraries from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
  <!-- Load Cannon.js physics engine -->
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #121212;
      color: #00FF66;
      font-family: 'Courier New', monospace;
    }
    
    #game-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      box-sizing: border-box;
      border: 3px dashed #9333EA;
      z-index: 10;
    }
    
    #game-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #121212;
    }
    
    #instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(18, 18, 18, 0.8);
      color: #00FF66;
      padding: 10px;
      border: 1px solid #00FF66;
      border-radius: 5px;
      z-index: 1000;
    }
    
    #debug-info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background-color: rgba(18, 18, 18, 0.8);
      color: #00FF66;
      padding: 10px;
      border: 1px solid #00FF66;
      border-radius: 5px;
      z-index: 1000;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    button {
      background-color: #9333EA;
      color: white;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 3px;
      margin: 5px;
    }
    
    button:hover {
      background-color: #7B2AC5;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas"></canvas>
  </div>
  
  <div id="instructions">
    <h3>Controls:</h3>
    <p>W/Up Arrow - Move Forward</p>
    <p>S/Down Arrow - Move Backward</p>
    <p>A/Left Arrow - Rotate Left</p>
    <p>D/Right Arrow - Rotate Right</p>
    <p>Space - Jump</p>
    <p>T - Toggle Debug Camera</p>
  </div>
  
  <div id="debug-info">
    Loading game...
  </div>

  <script>
    // Immediately executing function to avoid global namespace pollution
    (function() {
      // Debug logging
      const debugInfo = document.getElementById('debug-info');
      
      function log(message) {
        console.log(message);
        if (debugInfo) {
          debugInfo.innerHTML += message + '<br>';
          // Keep only recent messages
          const lines = debugInfo.innerHTML.split('<br>');
          if (lines.length > 20) {
            debugInfo.innerHTML = lines.slice(lines.length - 20).join('<br>');
          }
          // Auto-scroll to bottom
          debugInfo.scrollTop = debugInfo.scrollHeight;
        }
      }
      
      // Get URL parameters (for mode and character selection)
      const urlParams = new URLSearchParams(window.location.search);
      const selectedMode = urlParams.get('mode') || 'free-world';
      const selectedCharacter = urlParams.get('character') || 'american';
      
      log(`Selected mode: ${selectedMode}, character: ${selectedCharacter}`);
      
      // Main game variables
      let scene, camera, renderer;
      let canvas, clock;
      let physicsWorld;
      let cockroachModel, cockroachBody;
      let debugMode = false;
      let orbitControls;
      
      // Input state
      const keys = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        jump: false
      };
      
      // Initialize the game
      function init() {
        log('Initializing game...');
        
        // Get canvas
        canvas = document.getElementById('game-canvas');
        if (!canvas) {
          log('ERROR: Canvas not found!');
          return false;
        }
        
        try {
          // Initialize Three.js
          log('Setting up Three.js...');
          
          // Create renderer
          renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true
          });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.shadowMap.enabled = true;
          
          // Create scene
          scene = new THREE.Scene();
          scene.background = new THREE.Color(0x121212);
          
          // Create camera
          camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          camera.position.set(0, 5, 10);
          camera.lookAt(0, 0, 0);
          
          // Create debug controls (disabled by default)
          orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
          orbitControls.enabled = false;
          
          // Create clock
          clock = new THREE.Clock();
          
          // Setup environment
          setupEnvironment();
          
          // Initialize physics
          initPhysics();
          
          // Create cockroach
          createCockroach();
          
          // Setup input handlers
          setupInputHandlers();
          
          // Handle window resize
          window.addEventListener('resize', onWindowResize);
          
          // Start animation loop
          animate();
          
          log('Game initialized successfully!');
          return true;
        } catch (error) {
          log(`ERROR: ${error.message}`);
          return false;
        }
      }
      
      // Initialize physics world
      function initPhysics() {
        log('Initializing physics...');
        
        physicsWorld = new CANNON.World();
        physicsWorld.gravity.set(0, -9.82, 0); // Earth gravity
        physicsWorld.broadphase = new CANNON.NaiveBroadphase();
        physicsWorld.solver.iterations = 10;
        
        // Create ground plane - physics
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0 });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        physicsWorld.addBody(groundBody);
      }
      
      // Setup environment (ground, lights, etc)
      function setupEnvironment() {
        log('Setting up environment...');
        
        // Add lights
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 15);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // Add cyberpunk colored lights
        const purpleLight = new THREE.PointLight(0x9333EA, 1, 50);
        purpleLight.position.set(5, 5, 5);
        scene.add(purpleLight);
        
        const greenLight = new THREE.PointLight(0x00FF66, 1, 50);
        greenLight.position.set(-5, 3, -5);
        scene.add(greenLight);
        
        // Ground plane - visual
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({
          color: 0x333333,
          roughness: 0.8,
          metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Grid helper for cyberpunk aesthetic
        const gridHelper = new THREE.GridHelper(100, 100, 0x00FF66, 0x444444);
        scene.add(gridHelper);
        
        // Add placeholder debug cube
        const cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.set(3, 0.5, 3);
        scene.add(cube);
      }
      
      // Create cockroach character
      function createCockroach() {
        log(`Creating cockroach character: ${selectedCharacter}`);
        
        // Create placeholder box
        const geometry = new THREE.BoxGeometry(1, 0.5, 2);
        const material = new THREE.MeshStandardMaterial({ 
          color: selectedCharacter === 'american' ? 0xaa5500 : 0x442200,
          roughness: 0.7,
          metalness: 0.3
        });
        cockroachModel = new THREE.Mesh(geometry, material);
        cockroachModel.position.set(0, 1, 0);
        cockroachModel.castShadow = true;
        scene.add(cockroachModel);
        
        // Create physics body
        const shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.25, 1));
        cockroachBody = new CANNON.Body({ mass: 1 });
        cockroachBody.addShape(shape);
        cockroachBody.position.set(0, 1, 0);
        physicsWorld.addBody(cockroachBody);
        
        // Try to load model with multiple approaches
        setTimeout(() => {
          loadModelVersion1();
          
          // Try alternative approaches if first method doesn't work
          setTimeout(() => {
            if (!cockroachModelLoaded) {
              log("First loading method failed, trying alternative approach...");
              loadModelVersion2();
            }
          }, 3000);
        }, 1000);
      }
      
      // Track if the model has been loaded
      let cockroachModelLoaded = false;
      
      // First approach to load model - using standard paths
      function loadModelVersion1() {
        // Check for GLTFLoader
        if (typeof THREE.GLTFLoader === 'undefined') {
          log('WARNING: GLTFLoader not available (v1), using placeholder');
          return;
        }
        
        const loader = new THREE.GLTFLoader();
        
        log("Loading model - Approach 1");
        
        // Try to load with exact filenames first
        let modelPath = '';
        if (selectedCharacter === 'american') {
          modelPath = 'assets/models/American Cockroach.glb';
        } else {
          modelPath = 'assets/models/Oriental cockroach.glb';
        }
        
        // Log the model path we're trying
        log(`Trying to load model from: ${modelPath}`);
        
        // Attempt to load model
        loader.load(
          modelPath,
          function(gltf) {
            // Success callback
            log('Model loaded successfully! (v1)');
            
            // Remove placeholder model
            scene.remove(cockroachModel);
            
            // Add the new model
            cockroachModel = gltf.scene;
            cockroachModel.scale.set(0.5, 0.5, 0.5);
            cockroachModel.castShadow = true;
            scene.add(cockroachModel);
            
            // Mark model as loaded
            cockroachModelLoaded = true;
            
            // Update cockroach for rendering
            updateCockroach();
          },
          function(xhr) {
            // Progress callback
            const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
            log(`Loading model: ${percent}%`);
          },
          function(error) {
            // Error callback
            log(`Error loading model (v1): ${error.message}`);
          }
        );
      }
      
      // Second approach - try different paths and file locations
      function loadModelVersion2() {
        if (typeof THREE.GLTFLoader === 'undefined') {
          log('WARNING: GLTFLoader not available (v2), using placeholder');
          return;
        }
        
        const loader = new THREE.GLTFLoader();
        log("Loading model - Approach 2");
        
        // Generate all possible model paths to try
        const basePaths = [
          'assets/models/',
          'models/',
          '',
          '../assets/models/',
          '../models/'
        ];
        
        // Filename variations
        let fileNames = [];
        
        if (selectedCharacter === 'american') {
          fileNames = [
            'American Cockroach.glb',
            'american-cockroach.glb',
            'american_cockroach.glb',
            'AmericanCockroach.glb',
            'cockroach.glb'
          ];
        } else {
          fileNames = [
            'Oriental cockroach.glb',
            'oriental-cockroach.glb',
            'oriental_cockroach.glb',
            'OrientalCockroach.glb',
            'cockroach.glb'
          ];
        }
        
        // Generate all combinations and try them
        const paths = [];
        for (const basePath of basePaths) {
          for (const fileName of fileNames) {
            paths.push(basePath + fileName);
          }
        }
        
        log(`Trying ${paths.length} potential model paths...`);
        
        // Start trying each path
        tryNextPath(paths, 0);
      }
      
      // Try loading from each path one at a time
      function tryNextPath(paths, index) {
        if (index >= paths.length || cockroachModelLoaded) {
          if (!cockroachModelLoaded) {
            log("Couldn't load model from any path. Using placeholder.");
          }
          return;
        }
        
        const path = paths[index];
        log(`Trying path ${index+1}/${paths.length}: ${path}`);
        
        const loader = new THREE.GLTFLoader();
        loader.load(
          path,
          function(gltf) {
            // Success!
            log(`SUCCESS! Model loaded from: ${path}`);
            
            // Remove placeholder
            scene.remove(cockroachModel);
            
            // Use the loaded model
            cockroachModel = gltf.scene;
            cockroachModel.scale.set(0.5, 0.5, 0.5);
            cockroachModel.castShadow = true;
            scene.add(cockroachModel);
            
            // Mark as loaded
            cockroachModelLoaded = true;
          },
          function(xhr) {
            // Progress - don't log to avoid spam
          },
          function(error) {
            // Error, try next path
            log(`Failed with ${path}, trying next`);
            setTimeout(() => tryNextPath(paths, index + 1), 100);
          }
        );
      }
      
      // Setup input handlers
      function setupInputHandlers() {
        log('Setting up input handlers...');
        
        // Keyboard down
        window.addEventListener('keydown', function(e) {
          // Log key presses for debugging
          log(`Key pressed: ${e.code || e.keyCode}`);
          
          switch(e.code || e.key || e.keyCode) {
            case 'KeyW':
            case 'ArrowUp':
            case 'w':
            case 'W':
            case 38: // Up arrow keyCode
              keys.forward = true;
              break;
            case 'KeyS':
            case 'ArrowDown':
            case 's':
            case 'S':
            case 40: // Down arrow keyCode
              keys.backward = true;
              break;
            case 'KeyA':
            case 'ArrowLeft':
            case 'a':
            case 'A':
            case 37: // Left arrow keyCode
              keys.left = true;
              break;
            case 'KeyD':
            case 'ArrowRight':
            case 'd':
            case 'D':
            case 39: // Right arrow keyCode
              keys.right = true;
              break;
            case 'Space':
            case ' ':
            case 32: // Space keyCode
              keys.jump = true;
              break;
            case 'KeyT':
            case 't':
            case 'T':
            case 84: // T keyCode
              // Toggle debug mode
              debugMode = !debugMode;
              orbitControls.enabled = debugMode;
              log(`Debug mode: ${debugMode ? 'ON' : 'OFF'}`);
              break;
          }
        });
        
        // Keyboard up
        window.addEventListener('keyup', function(e) {
          switch(e.code || e.key || e.keyCode) {
            case 'KeyW':
            case 'ArrowUp':
            case 'w':
            case 'W':
            case 38: // Up arrow keyCode
              keys.forward = false;
              break;
            case 'KeyS':
            case 'ArrowDown':
            case 's':
            case 'S':
            case 40: // Down arrow keyCode
              keys.backward = false;
              break;
            case 'KeyA':
            case 'ArrowLeft':
            case 'a':
            case 'A':
            case 37: // Left arrow keyCode
              keys.left = false;
              break;
            case 'KeyD':
            case 'ArrowRight':
            case 'd':
            case 'D':
            case 39: // Right arrow keyCode
              keys.right = false;
              break;
            case 'Space':
            case ' ':
            case 32: // Space keyCode
              keys.jump = false;
              break;
          }
        });
      }
      
      // Handle window resize
      function onWindowResize() {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      }
      
      // Update cockroach movement
      function updateCockroach() {
        if (!cockroachBody || !cockroachModel) return;
        
        // Log active keys for debugging
        if (keys.forward || keys.backward || keys.left || keys.right || keys.jump) {
          log(`Inputs: F=${keys.forward}, B=${keys.backward}, L=${keys.left}, R=${keys.right}, J=${keys.jump}`);
        }
        
        // Movement parameters
        const force = 10;
        const torque = 5;
        
        // Apply forces based on input
        if (keys.forward) {
          cockroachBody.applyLocalForce(new CANNON.Vec3(0, 0, -force), new CANNON.Vec3(0, 0, 0));
        }
        if (keys.backward) {
          cockroachBody.applyLocalForce(new CANNON.Vec3(0, 0, force), new CANNON.Vec3(0, 0, 0));
        }
        if (keys.left) {
          cockroachBody.applyTorque(new CANNON.Vec3(0, torque, 0));
        }
        if (keys.right) {
          cockroachBody.applyTorque(new CANNON.Vec3(0, -torque, 0));
        }
        if (keys.jump && cockroachBody.position.y < 1.1) {
          cockroachBody.applyImpulse(new CANNON.Vec3(0, 5, 0), cockroachBody.position);
        }
        
        // Update visual model position to match physics body
        cockroachModel.position.copy(cockroachBody.position);
        cockroachModel.quaternion.copy(cockroachBody.quaternion);
      }
      
      // Update camera to follow cockroach
      function updateCamera() {
        if (!cockroachModel || !camera || debugMode) return;
        
        // Third-person camera offset
        const offset = new THREE.Vector3(0, 3, 6);
        offset.applyQuaternion(cockroachModel.quaternion);
        
        // Set camera position
        const targetPosition = new THREE.Vector3()
          .copy(cockroachModel.position)
          .add(offset);
        camera.position.copy(targetPosition);
        camera.lookAt(cockroachModel.position);
      }
      
      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        
        // Get delta time
        const delta = clock.getDelta();
        
        // Update physics
        if (physicsWorld) {
          physicsWorld.step(1/60, delta, 3);
        }
        
        // Update cockroach
        updateCockroach();
        
        // Update camera
        updateCamera();
        
        // Update debug controls if needed
        if (debugMode && orbitControls) {
          orbitControls.update();
        }
        
        // Render scene
        if (renderer && scene && camera) {
          renderer.render(scene, camera);
        }
      }
      
      // Start the game
      init();
      
      // Tell parent window we're loaded
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({ type: 'game-loaded' }, '*');
        log('Sent loaded message to parent');
      }
    })();
  </script>
</body>
</html>
