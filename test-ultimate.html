<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">  <title>Cockroach Run - Ultimate Test</title>
  <!-- Font imports -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@400;600;700&display=swap" rel="stylesheet" />
  <!-- CSS variables -->
  <link rel="stylesheet" href="css/variables.css" />
  <!-- Message remover script, loads first to immediately remove unwanted elements -->
  <script src="message-remover.js"></script>
  <!-- Load Three.js libraries from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
  <!-- Load Cannon.js physics engine -->
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
      body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: var(--font-body);
      background-color: #1a1a1a;
      color: #ffffff;
    }
    
    #game-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000000;
    }
    
    /* Debug panel - hidden by default */
    #debug-info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      width: 600px;
      max-width: calc(100% - 20px);
      height: 150px;
      max-height: 25vh;
      background-color: rgba(0, 0, 0, 0.7);
      color: #00ff00;
      border: 1px solid #00ff00;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
      padding: 5px;
      z-index: 100;
      display: none; /* Hidden by default */
    }
    
    #position-display {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.5);
      color: #ffffff;
      padding: 5px;
      font-family: monospace;
      font-size: 12px;
      z-index: 100;
      display: none; /* Hidden by default */
    }
    
    /* Controls toggle button to match game UI */
    #controls-toggle {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      background-color: #000000;
      color: #FF8000;
      border-radius: 0;
      display: flex;
      justify-content: center;
      align-items: center;      cursor: pointer;
      z-index: 1000;
      font-size: 20px;
      box-shadow: none;
      border: 2px solid #FF8000;
      font-family: var(--font-heading);
      font-weight: bold;
      transition: background-color 0.2s;
    }
    
    #controls-toggle:hover {
      background-color: #444;
    }
    
    /* Controls panel - hidden by default */
    #controls-info {
      position: absolute;
      top: 60px;
      right: 10px;      background-color: #000000;
      color: #FF8000;
      border: 2px solid #FF8000;
      padding: 15px;
      font-family: var(--font-body);
      font-size: 14px;
      z-index: 100;
      display: none;
      border-radius: 0;
      box-shadow: none;
      max-width: 300px;
    }
      /* Settings menu to match game UI exactly */
    #settings-menu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #000000;
      color: #FF8000;
      border: 2px solid #FF8000;
      padding: 25px;
      z-index: 2000;
      width: 80%;
      max-width: 500px;
      border-radius: 0;
      display: none;
      box-shadow: none;
      font-family: var(--font-body);
    }
      #settings-menu h2 {
      text-align: center;
      margin-top: 0;
      margin-bottom: 20px;
      color: #FF8000;
      font-size: 24px;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: bold;
      font-family: var(--font-heading);
    }
    
    .settings-row {
      display: flex;
      justify-content: space-between;
      margin: 15px 0;
      align-items: center;
      border-bottom: 1px solid #333;
      padding-bottom: 12px;
    }
    
    .settings-row:last-of-type {
      border-bottom: none;
    }
    
    .settings-row label {
      font-size: 16px;
      color: #FF8000;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
      .settings-row button, 
    #settings-menu button {
      background-color: #000000;
      color: #FF8000;
      border: 2px solid #FF8000;
      padding: 8px 15px;
      border-radius: 0;
      cursor: pointer;
      font-family: var(--font-heading);
      font-weight: bold;
      min-width: 80px;
      transition: all 0.2s;
    }
    
    .settings-row button:hover,
    #settings-menu button:hover {
      background-color: #111111;
    }
    
    .settings-row button:active,
    #settings-menu button:active {
      background-color: #111111;
    }
      #settings-menu button {
      background-color: #121212;
      color: #FF8000;
      border: 1px solid #FF8000;
      padding: 5px 10px;
      font-family: var(--font-heading);
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    #settings-menu button:hover {
      background-color: #FF8000;
      color: #121212;
    }
    
    #return-to-menu-button {
      background-color: #000000;
      color: #FF8000;
      border: 2px solid #FF8000;
      padding: 10px 15px;
      width: 100%;
      margin-top: 20px;
      font-size: 16px;
      text-transform: uppercase;
      border-radius: 0;
    }
    
    #return-to-menu-button:hover {
      background-color: #111111;
    }
      /* Music track selector styling - Updated to match main settings menu */
    .custom-dropdown-wrapper {
      position: relative;
      width: 55%;
      z-index: 100;
    }

    .custom-dropdown-trigger {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 20px 4px 8px;
      background-color: rgba(0, 0, 0, 1);
      border: 1px solid var(--orange);
      color: var(--orange);
      cursor: pointer;
      font-family: var(--font-body);
      width: 100%;
      font-size: 0.9em;
      position: relative;
      z-index: 1500;
    }

    .custom-dropdown-trigger::after {
      content: '';
      position: absolute;
      top: 50%;
      right: 12px;
      transform: translateY(-50%);
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-top: 6px solid var(--orange);
      pointer-events: none;
      transition: border-top-color 0.2s ease;
    }

    .custom-dropdown-trigger:hover {
      background-color: rgba(0, 0, 0, 0.9);
      border-color: var(--orange);
    }

    .custom-dropdown-trigger:hover::after {
      border-top-color: var(--orange);
    }

    .custom-dropdown-trigger:focus {
      outline: 2px solid var(--orange);
      outline-offset: 2px;
      border-color: var(--orange);
      background-color: rgba(0, 0, 0, 0.9);
    }

    .custom-options-list {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      width: 100%;
      z-index: 10;
      background-color: #000000;
      border: 1px solid var(--orange);
      border-top: none;
      list-style: none;
      padding: 0;
      margin: 0;
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      visibility: hidden;
      transition: max-height 0.3s ease-out, opacity 0.3s ease-out, visibility 0s linear 0.3s;
    }

    .custom-options-list.visible {
      max-height: 300px;
      opacity: 1;
      visibility: visible !important;
      display: block;
      transition: max-height 0.3s ease-in, opacity 0.2s ease-in, visibility 0s linear 0s;
      z-index: 9999;
      overflow-y: auto;
      background-color: #000000;
      border: 1px solid var(--orange);
      scrollbar-width: thin;
      scrollbar-color: var(--orange) #121212;
    }

    .custom-options-list.visible::-webkit-scrollbar {
      width: 8px;
    }

    .custom-options-list.visible::-webkit-scrollbar-track {
      background: #121212;
    }

    .custom-options-list.visible::-webkit-scrollbar-thumb {
      background-color: var(--orange);
      border-radius: 0;
    }

    .custom-option {
      padding: 4px 8px;
      color: var(--orange);
      background-color: #000000;
      cursor: pointer;
      transition: background-color 0.1s ease, color 0.1s ease;
      font-family: var(--font-body);
      font-size: 0.9em;
    }

    .custom-option:hover,
    .custom-option:focus {
      background-color: #000000;
      color: #FFB84D;
      outline: none;
    }

    .original-select {
      position: absolute;
      left: -9999px;
      top: auto;
      width: 1px;
      height: 1px;
      overflow: hidden;
      opacity: 0;
      pointer-events: none;
      border: 0;
      padding: 0;
      margin: -1px;
    }
    
    /* Now Playing indicator */
    .now-playing {
      font-size: 10px;
      color: #FF8000;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 1px;
      display: block;
    }
    
    #loading-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);      background-color: rgba(0, 0, 0, 0.7);
      color: #ffffff;
      padding: 20px;
      border-radius: 5px;
      font-family: var(--font-body);
      z-index: 1000;
    }
    
    /* Touch controls style - hidden by default */
    #touch-controls {
      display: none;
    }
    
    #touch-controls button {
      font-size: 24px;
      min-width: 60px;
      height: 60px;
      margin: 5px;
      padding: 10px;
      user-select: none;
      -webkit-user-select: none;
      background-color: rgba(80, 80, 80, 0.5);
      color: white;
      border: 1px solid #555;
      border-radius: 5px;
    }
    
    /* More visible focus for keyboard navigation */
    #game-container:focus {
      outline: 3px solid #00ff00;
    }
    
    /* Music track selection dropdown */
    #track-selector {
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: relative;
    }
  
    
    @media (max-width: 768px) {
      #debug-info {
        width: 90%;
        font-size: 10px;
      }
      
      #controls-info {
        font-size: 12px;
      }
      
      #touch-controls button {
        font-size: 20px;
        min-width: 50px;
        height: 50px;
      }
      
      /* Mobile styles for custom dropdown */
      .custom-dropdown-wrapper {
        min-width: 120px;
      }
      
      .custom-dropdown-trigger {
        font-size: 12px;
        padding: 6px 8px;
        min-height: 36px;
      }
      
      .custom-options-list {
        max-height: 120px;
        width: 100%;
        min-width: 150px;
      }
      
      .custom-option {
        font-size: 12px;
        padding: 8px 10px;
        min-height: 32px;
        display: flex;
        align-items: center;
      }
    }
  </style>
  <!-- Zoom functionality fix -->
  <script src="zoom-fix.js"></script>
  <!-- Audio Manager for music control -->
  <script src="js/audio.js"></script>
</head>
<body>
  <div id="game-container" tabindex="0"><!-- Three.js will render here --></div>
  <div id="debug-info"></div>
  <div id="position-display"></div>
  
  <!-- Controls toggle button to match game UI -->
  <button id="controls-toggle">?</button>
    <!-- Controls info panel -->
  <div id="controls-info">
    <h3 style="margin-top: 0;">Controls:</h3>
    <p>W/Up Arrow - Move Forward</p>
    <p>S/Down Arrow - Move Backward</p>
    <p>A/Left Arrow - Rotate Left</p>
    <p>D/Right Arrow - Rotate Right</p>
    <p>Space - Jump</p>
    <p>F - Zoom In</p>
    <p>G - Zoom Out</p>
    <p>ESC - Settings Menu</p>
    <p>T - Toggle Debug Camera</p>
  </div>
    <!-- Settings menu (appears when ESC is pressed) -->
  <div id="settings-menu" style="display: none;">
    <h2 class="screen-title">Game Settings</h2>
    <div class="now-playing" id="now-playing">NOW PLAYING: <span id="now-playing-text"></span></div>
    
    <div class="settings-row">
      <label for="touch-controls-toggle">Touch Controls</label>
      <button id="touch-controls-toggle">Show</button>
    </div>
    
    <div class="settings-row">
      <label for="debug-toggle">Debug Info</label>
      <button id="debug-toggle">Show</button>
    </div>
      <div class="settings-row">
      <label for="track-selector">Music Track</label>
      <div class="custom-dropdown-wrapper" data-target-select="music-track-select">
        <!-- Hidden original select -->
        <select id="music-track-select" class="original-select" aria-hidden="true" tabindex="-1">
          <option value="checkpoint-chaser">Checkpoint Chaser</option>
          <option value="cockroach-comeback">Cockroach Comeback</option>
          <option value="cockroach-run" selected>Cockroach Run</option>
          <option value="dodge-weave-waltz">Dodge and Weave Waltz</option>
          <option value="neon-roach-runnin">Neon Roach Runnin</option>
          <option value="run-roach-run">Run, Roach, Run!</option>
          <option value="urban-jungle-jive">Urban Jungle Jive</option>
        </select>
        <!-- Visible custom dropdown trigger -->
        <div class="custom-dropdown-trigger" role="combobox" aria-haspopup="listbox" aria-expanded="false" aria-labelledby="music-track-label selected-music-text" tabindex="0">
          <span class="selected-option-text" id="selected-music-text">Cockroach Run</span>
        </div>
        <!-- Custom options list -->
        <ul class="custom-options-list" role="listbox" aria-labelledby="music-track-label" hidden>
          <li class="custom-option" data-value="checkpoint-chaser" role="option" tabindex="-1">Checkpoint Chaser</li>
          <li class="custom-option" data-value="cockroach-comeback" role="option" tabindex="-1">Cockroach Comeback</li>
          <li class="custom-option" data-value="cockroach-run" role="option" tabindex="-1">Cockroach Run</li>
          <li class="custom-option" data-value="dodge-weave-waltz" role="option" tabindex="-1">Dodge and Weave Waltz</li>
          <li class="custom-option" data-value="neon-roach-runnin" role="option" tabindex="-1">Neon Roach Runnin</li>
          <li class="custom-option" data-value="run-roach-run" role="option" tabindex="-1">Run, Roach, Run!</li>
          <li class="custom-option" data-value="urban-jungle-jive" role="option" tabindex="-1">Urban Jungle Jive</li>
        </ul>
      </div>
    </div>
    
    <div class="settings-row">
      <label for="music-toggle">Music</label>
      <button id="music-toggle">On</button>
    </div>
    
    <div class="settings-row">
      <label for="sfx-toggle">Sound Effects</label>
      <button id="sfx-toggle">On</button>
    </div>
    
    <div class="settings-row" style="border-bottom: none; justify-content: center;">
      <button id="close-settings">Continue Game</button>
    </div>
    
    <button id="return-to-menu-button">Return to Main Menu</button>
  </div>
  
  <div id="loading-indicator" style="display: none;"></div>
  
  <!-- Audio elements for the game -->
  <audio id="button-click" src="audio/button-click.mp3" preload="auto"></audio>
  <audio id="scatter-sound" src="audio/scatter.mp3" preload="auto"></audio>
  <audio id="menu-music" loop preload="auto"></audio>
  <audio id="game-music" loop preload="auto"></audio>
  
  <!-- Zoom notification element -->
  <div id="zoom-notification" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.5); color: #FF8000; padding: 10px 20px; border-radius: 5px; font-family: var(--font-body); font-weight: bold; z-index: 1000; opacity: 0; transition: opacity 0.3s; pointer-events: none;"></div>
    <!-- Additional scripts -->
  <script src="js/autoplay-helper.js"></script>
  <script src="direct-keyboard-zoom.js"></script>
  <script src="direct-zoom-handler.js"></script>
  
  <script>
    // Function to show zoom notification
    function showZoomNotification(message) {
      const notification = document.getElementById('zoom-notification');
      if (notification) {
        notification.textContent = message;
        notification.style.opacity = '1';
        
        // Hide after 1 second
        setTimeout(() => {
          notification.style.opacity = '0';
        }, 1000);
      }
    }
  </script>
  
  <script>
    // EXTREMELY aggressive removal of any green focus messages
    (function permanentlyRemoveGreenMessages() {
      // First, immediate removal of anything matching
      function removeMessages() {
        // Target by multiple criteria to catch all variations
        const selectors = [
          'div[style*="color: rgb(0, 255, 102)"]', 
          'div[style*="color: #00FF66"]',
          'div[style*="color:#00FF66"]',
          'div[style*="bottom: 10px; right: 10px"]',
          'div[data-component-name="<div />"]',
          'div[style*="monospace"]'
        ];
        
        // Try to find by combined selectors
        let messages = document.querySelectorAll(selectors.join(','));
        let removed = false;
        
        messages.forEach(element => {
          // If it has text about clicking OR has green color OR is at the bottom right
          if (element && (
              (element.textContent && element.textContent.includes('Click in the game area')) ||
              (element.style && (element.style.color === '#00FF66' || element.style.color === 'rgb(0, 255, 102)')) ||
              (element.style && element.style.bottom === '10px' && element.style.right === '10px')
          )) {
            if (element.parentNode) {
              element.parentNode.removeChild(element);
              removed = true;
              console.log('Removed focus message');
            }
          }
        });
        
        // Fallback - any div with that exact text
        document.querySelectorAll('div').forEach(el => {
          if (el.textContent && el.textContent.trim() === 'Click in the game area to enable controls') {
            if (el.parentNode) {
              el.parentNode.removeChild(el);
              removed = true;
              console.log('Removed by text content');
            }
          }
        });
        
        return removed;
      }
      
      // Run immediately
      removeMessages();
      
      // Also set up a monitor to remove any that appear later
      setInterval(removeMessages, 500);
    })();
    
    // Immediately executing function to avoid global namespace pollution
    (function() {
      // Global variables
      let scene, camera, renderer;
      let world, cockroachModel, cockroachBody;
      let clock, controls;
      let keys = {};
      let isJumping = false;
      let jumpTime = 0;
      let jumpHeight = 0;
      let debugMode = false;
      let frameCount = 0;
      let orbitControls = null;
      
      // FOV Zoom variables
      let defaultFOV = 75;
      let currentFOV = defaultFOV;
      let minFOV = 45;
      let maxFOV = 90;
      let zoomStep = 5;
      
      // Enhanced log with color-coded messages and categories
      function log(message, type = 'info') {
        // Format timestamp
        const now = new Date();
        const timestamp = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')}`;
        
        // Create log entry
        const debugInfo = document.getElementById('debug-info');
        if (debugInfo) {
          const logEntry = document.createElement('div');
          logEntry.style.margin = '2px 0';
          
          // Set color based on type - using consistent black and orange theme
          let color = '#FF8000'; // Default orange for all messages
          
          // Style with consistent black/orange theme
          logEntry.innerHTML = `<span style="color:#FF8000">[${timestamp}]</span> <span style="color:${color}">${message}</span>`;
          debugInfo.appendChild(logEntry);
          
          // Scroll to bottom
          debugInfo.scrollTop = debugInfo.scrollHeight;
          
          // Limit entries
          while (debugInfo.childElementCount > 50) {
            debugInfo.removeChild(debugInfo.firstChild);
          }
        }
        console.log(`[${type.toUpperCase()}] ${message}`);
      }
      
      // Initialize the game when the DOM is loaded
      window.onload = function() {
        // Initialize AudioManager if it exists and we're in a browser context
        if (window.AudioManager) {
          log('Initializing AudioManager...', 'info');
          window.AudioManager.init();
          
          // Verify audio elements and display state for debugging
          const audioElements = {
            'menu-music': document.getElementById('menu-music'),
            'game-music': document.getElementById('game-music'),
            'button-click': document.getElementById('button-click'),
            'scatter-sound': document.getElementById('scatter-sound')
          };
          
          let audioElementsLog = 'Audio Elements Status:\n';
          for (const [id, element] of Object.entries(audioElements)) {
            audioElementsLog += `${id}: ${element ? 'Found' : 'MISSING'}\n`;
            if (!element) {
              log(`ERROR: Audio element ${id} not found in the DOM!`, 'error');
            }
          }
          log(audioElementsLog, 'debug');
          
          // Force loading the correct tracks into audio elements
          if (audioElements['game-music']) {
            const gameTrackId = window.AudioManager.gameTrackId;
            const gameMusicPath = `assets/sounds/music/${window.AudioManager.trackMap[gameTrackId]}`;
            
            log(`Setting game music source to: ${gameMusicPath}`, 'info');
            audioElements['game-music'].src = gameMusicPath;
            audioElements['game-music'].load();
            
            // Also make sure button click and scatter sounds have correct paths
            if (audioElements['button-click'] && !audioElements['button-click'].src) {
              audioElements['button-click'].src = 'assets/sounds/button-click.mp3';
            }
            
            if (audioElements['scatter-sound'] && !audioElements['scatter-sound'].src) {
              audioElements['scatter-sound'].src = 'assets/sounds/scatter.mp3';
            }
          }
          
          // Set to game context since we're loading the game
          log('Setting audio context to GAME', 'info');
          window.AudioManager.setContext(true);
        } else {
          log('AudioManager not found!', 'error');
        }
        init();
      };
      
      // Get URL parameters (for mode and character selection)
      const urlParams = new URLSearchParams(window.location.search);
      const selectedMode = urlParams.get('mode') || 'free-world';
      const selectedCharacter = urlParams.get('character') || 'default-roach';
        // Function to initialize music track selector with new dropdown system
      function initMusicTrackSelector() {
        console.log('Initializing music track selector...');
        const customDropdownWrapper = document.querySelector('.custom-dropdown-wrapper[data-target-select="music-track-select"]');
        const customDropdownTrigger = customDropdownWrapper?.querySelector('.custom-dropdown-trigger');
        const customOptionsList = customDropdownWrapper?.querySelector('.custom-options-list');
        const customOptions = customDropdownWrapper?.querySelectorAll('.custom-option');
        const selectedText = customDropdownWrapper?.querySelector('.selected-option-text');
        const nowPlaying = document.getElementById('now-playing');
        const nowPlayingText = document.getElementById('now-playing-text');
        
        console.log('Dropdown elements:', {
          wrapper: !!customDropdownWrapper,
          trigger: !!customDropdownTrigger,
          optionsList: !!customOptionsList,
          selectedText: !!selectedText,
          optionsCount: customOptions?.length || 0
        });
        
        if (!customDropdownWrapper || !customDropdownTrigger || !customOptionsList || !selectedText) {
          log('Custom dropdown elements not found', 'error');
          return;
        }
        
        // Set initial track from AudioManager's game track
        if (window.AudioManager && window.AudioManager.gameTrackId) {
          const gameTrack = window.AudioManager.gameTrackId;
          const trackElement = document.querySelector(`.custom-option[data-value="${gameTrack}"]`);
          if (trackElement) {
            selectedText.textContent = trackElement.textContent;
            if (nowPlayingText) {
              nowPlayingText.textContent = trackElement.textContent;
              if (nowPlaying) nowPlaying.style.display = 'block';
            }
          }
        }
        
        // Listen for track change events from AudioManager
        window.addEventListener('trackChanged', function(e) {
          if (e.detail && e.detail.trackId) {
            if (window.AudioManager && window.AudioManager.inGameContext) {
              const trackElement = document.querySelector(`.custom-option[data-value="${e.detail.trackId}"]`);
              if (trackElement) {
                selectedText.textContent = trackElement.textContent;
                if (nowPlayingText) {
                  nowPlayingText.textContent = trackElement.textContent;
                  if (nowPlaying) nowPlaying.style.display = 'block';
                }
                
                // Update the game track in AudioManager
                if (window.AudioManager) {
                  window.AudioManager.gameTrackId = e.detail.trackId;
                  localStorage.setItem('gameTrackId', e.detail.trackId);
                }
              }
            }
          }
        });
        
        // Toggle dropdown on trigger click
        customDropdownTrigger.addEventListener('click', function() {
          const isVisible = customOptionsList.classList.contains('visible');
          if (isVisible) {
            customOptionsList.classList.remove('visible');
            customDropdownTrigger.setAttribute('aria-expanded', 'false');
            customOptionsList.setAttribute('hidden', '');
          } else {
            customOptionsList.classList.add('visible');
            customDropdownTrigger.setAttribute('aria-expanded', 'true');
            customOptionsList.removeAttribute('hidden');
          }
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
          if (!customDropdownWrapper.contains(e.target)) {
            customOptionsList.classList.remove('visible');
            customDropdownTrigger.setAttribute('aria-expanded', 'false');
            customOptionsList.setAttribute('hidden', '');
          }
        });
        
        // Handle keyboard navigation
        customDropdownTrigger.addEventListener('keydown', function(e) {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            this.click();
          }
        });
        
        // Track selection event handler
        customOptions.forEach(option => {
          option.addEventListener('click', function() {
            const trackId = this.getAttribute('data-value');
            const trackName = this.textContent;
            
            // Update UI
            selectedText.textContent = trackName;
            customOptionsList.classList.remove('visible');
            customDropdownTrigger.setAttribute('aria-expanded', 'false');
            customOptionsList.setAttribute('hidden', '');
            
            if (nowPlayingText) {
              nowPlayingText.textContent = trackName;
              if (nowPlaying) nowPlaying.style.display = 'block';
            }
            
            // Change track via AudioManager - directly update game music
            if (window.AudioManager) {
              // Update the game track ID
              window.AudioManager.gameTrackId = trackId;
              localStorage.setItem('gameTrackId', trackId);
              

              // Force game music to change and play immediately
              window.AudioManager.playMusicInGameContext();
              

              // Also update the current track ID for compatibility with other parts of the code
              window.AudioManager.currentTrackId = trackId;
              

              // Extra step: Double-check that the audio element has the correct source
              if (window.AudioManager.gameMusic) {
                const expectedSrc = `assets/sounds/music/${window.AudioManager.trackMap[trackId]}`;
                const currentSrc = window.AudioManager.gameMusic.src;
                log(`Current audio src: ${currentSrc}`, 'debug');
                
                // Check if the source needs updating
                if (!currentSrc || currentSrc.indexOf(window.AudioManager.trackMap[trackId]) === -1) {
                  log(`Forcing audio source update to: ${expectedSrc}`, 'warning');
                  window.AudioManager.gameMusic.src = expectedSrc;
                  window.AudioManager.gameMusic.load();
                  
                  // Try to play immediately if not muted
                  if (!window.AudioManager.isMuted) {
                    window.AudioManager.gameMusic.play()
                      .then(() => log('Game track playing after direct src update', 'info'))
                      .catch(e => log('Failed to play after src update: ' + e.message, 'error'));
                  }
                } else {
                  log('Audio source already correct, no update needed', 'debug');
                }
              }
              

              log(`Changed game music to: ${trackName}`, 'info');
            }          });
        });
      }
      
      log(`Selected mode: ${selectedMode}, character: ${selectedCharacter}`);
      
      // Main game variables
      // Canvas is managed directly by renderer
      
      // Input state
      keys = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        jump: false
      };
      
      // Initialize the game and set up UI controls
      function init() {
        log('========================================', 'info');
        log('COCKROACH RUN - GAME INITIALIZING', 'info');
        log('========================================', 'info');
        
        // Hide loading indicator, we don't need it
        document.getElementById('loading-indicator').style.display = 'none';
        
        // Set up controls toggle button
        document.getElementById('controls-toggle').addEventListener('click', function() {
          const controlsPanel = document.getElementById('controls-info');
          controlsPanel.style.display = controlsPanel.style.display === 'none' ? 'block' : 'none';
        });
        
        // Set up settings menu and ESC key handling
        const settingsMenu = document.getElementById('settings-menu');
        const closeSettings = document.getElementById('close-settings');
        
        // ESC key toggles settings menu
        document.addEventListener('keydown', function(e) {
          if (e.key === 'Escape' || e.keyCode === 27) {
            toggleSettingsMenu();
          }
        });
        
        // Function to toggle settings menu visibility
        function toggleSettingsMenu() {
          if (settingsMenu.style.display === 'block') {
            settingsMenu.style.display = 'none';
            resumeGame();
          } else {
            settingsMenu.style.display = 'block';
            pauseGame();
          }
        }
        
        // Close button for settings
        closeSettings.addEventListener('click', function() {
          settingsMenu.style.display = 'none';
          resumeGame();
        });
        
        // Initialize music track selector
        initMusicTrackSelector();
        
        // Return to main menu button - EXTREMELY simplified to guarantee success
        const returnToMenuButton = document.getElementById('return-to-menu-button');
        if (returnToMenuButton) {
          returnToMenuButton.addEventListener('click', function() {
            log('Returning to main menu', 'info');
            
            // Hide all menus to prevent flash
            const settingsMenu = document.getElementById('settings-menu');
            if (settingsMenu) settingsMenu.style.display = 'none';
            
            const controlsInfo = document.getElementById('controls-info');
            if (controlsInfo) controlsInfo.style.display = 'none';
            
            const debugInfo = document.getElementById('debug-info');
            if (debugInfo) debugInfo.style.display = 'none';
            
            // Stop all animations and rendering immediately
            gamePaused = true;
            
            // Force stop any game music immediately
            if (window.AudioManager) {
              if (window.AudioManager.gameMusic && !window.AudioManager.gameMusic.paused) {
                log('Forcefully stopping game music before returning to menu', 'info');
                window.AudioManager.gameMusic.pause();
                window.AudioManager.gameMusic.currentTime = 0;
              }
              
              // Set the local audio context to menu
              log('Setting audio context back to MENU', 'info');
              window.AudioManager.setContext(false);
            }
            
            // Tell the parent window we're returning to menu so it can handle menu music
            try {
              window.parent.postMessage({ 
                type: 'return-to-menu',
                audioContext: 'menu'
              }, '*');
            } catch (err) {
              log('Error notifying parent of menu return: ' + err.message, 'error');
            }
            
            // Simple and reliable approach - use parent's top-level function
            try {
              // The parent's Game.returnToMenu has been fixed to be extremely reliable
              window.parent.Game.returnToMenu();
            } catch (e) {
              // If all else fails, reload the page (last resort)
              window.parent.location.reload();
            }
          });
        }
        
        // Debug toggle button
        document.getElementById('debug-toggle').addEventListener('click', function() {
          const debugInfo = document.getElementById('debug-info');
          const currentDisplay = debugInfo.style.display === 'block';
          
          debugInfo.style.display = currentDisplay ? 'none' : 'block';
          this.textContent = currentDisplay ? 'Show' : 'Hide';
        });
        
        // Music toggle button - completely rewritten to work properly
        document.getElementById('music-toggle').addEventListener('click', function() {
          try {
            // First try the local AudioManager we've added
            if (window.AudioManager) {
              const audioManager = window.AudioManager;
              

              // Toggle the mute state directly using AudioManager's method
              audioManager.isMuted = !audioManager.isMuted;
              

              // Explicitly handle the currently playing game music
              if (audioManager.gameMusic) {
                if (audioManager.isMuted) {
                  // If muted, pause the game music immediately
                  audioManager.gameMusic.pause();
                  log('Game music explicitly paused due to mute toggle', 'info');
                } else {
                  // If unmuted and we're in game context, resume playing the game music
                  if (audioManager.inGameContext) {
                    audioManager.gameMusic.play().catch(e => log('Could not autoplay game music: ' + e.message, 'warn'));
                    log('Game music explicitly resumed', 'info');
                  }
                }
              }
              
              // Apply general mute state for other sounds
              audioManager.applyMuteState();
              localStorage.setItem('isMuted', JSON.stringify(audioManager.isMuted));
              
              // Update button text to match actual state
              this.textContent = audioManager.isMuted ? 'Off' : 'On';
              log('Music turned ' + (audioManager.isMuted ? 'off' : 'on'), 'info');
              
              // Also update SFX toggle to match
              const sfxToggle = document.getElementById('sfx-toggle');
              if (sfxToggle) {
                sfxToggle.textContent = audioManager.isMuted ? 'Off' : 'On';
              }
            } 
            // Fallback to parent window if local AudioManager isn't available
            else if (window.parent && window.parent.AudioManager) {
              const audioManager = window.parent.AudioManager;
              

              // Toggle the mute state directly using AudioManager's method
              audioManager.isMuted = !audioManager.isMuted;
              audioManager.applyMuteState();
              localStorage.setItem('isMuted', JSON.stringify(audioManager.isMuted));
              
              // Update button text to match actual state
              this.textContent = audioManager.isMuted ? 'Off' : 'On';
              log('Music turned ' + (audioManager.isMuted ? 'off' : 'on'), 'info');
              
              // Also update SFX toggle to match
              const sfxToggle = document.getElementById('sfx-toggle');
              if (sfxToggle) {
                sfxToggle.textContent = audioManager.isMuted ? 'Off' : 'On';
              }
            } else {
              // Visual toggle as fallback
              this.textContent = this.textContent === 'On' ? 'Off' : 'On';
              log('AudioManager not accessible, visual toggle only', 'warn');
              
              // Try parent window direct method
              try {
                window.parent.postMessage({ type: 'toggle-audio' }, '*');
              } catch (err) {}
            }
          } catch (e) {
            // Still toggle visually so the button feels responsive
            this.textContent = this.textContent === 'On' ? 'Off' : 'On';
            log('Error toggling audio: ' + e.message, 'error');
          }
        });
        
        // SFX toggle button
        document.getElementById('sfx-toggle').addEventListener('click', function() {
          try {
            // First try the local AudioManager we've added
            if (window.AudioManager) {
              const audioManager = window.AudioManager;
              
              // Toggle SFX volume
              audioManager.sfxVolume = audioManager.sfxVolume > 0 ? 0 : 1.0;
              audioManager.applyVolumeSettings();
              localStorage.setItem('sfxVolume', audioManager.sfxVolume);
              
              // Update button text
              this.textContent = audioManager.sfxVolume > 0 ? 'On' : 'Off';
              log('Sound effects turned ' + (audioManager.sfxVolume > 0 ? 'on' : 'off'), 'info');
            } 
            // Fallback to parent window if local AudioManager isn't available
            else if (window.parent && window.parent.AudioManager) {
              const audioManager = window.parent.AudioManager;
              
              // Toggle SFX volume
              audioManager.sfxVolume = audioManager.sfxVolume > 0 ? 0 : 1.0;
              audioManager.applyVolumeSettings();
              localStorage.setItem('sfxVolume', audioManager.sfxVolume);
              
              // Update button text
              this.textContent = audioManager.sfxVolume > 0 ? 'On' : 'Off';
              log('Sound effects turned ' + (audioManager.sfxVolume > 0 ? 'on' : 'off'), 'info');
            } else {
              // Visual toggle as fallback
              this.textContent = this.textContent === 'On' ? 'Off' : 'On';
              log('AudioManager not accessible, visual toggle only', 'warn');
              
              // Try parent window direct method
              try {
                window.parent.postMessage({ type: 'toggle-sfx' }, '*');
              } catch (err) {}
            }
          } catch (e) {
            // Visual toggle as fallback
            this.textContent = this.textContent === 'On' ? 'Off' : 'On';
            log('Error toggling SFX: ' + e.message, 'error');
          }
        });
        
        // Game state variables
        let gamePaused = false;
        
        // Function to pause game
        function pauseGame() {
          gamePaused = true;
          log('Game paused', 'info');
        }
        
        // Function to resume game
        function resumeGame() {
          gamePaused = false;
          log('Game resumed', 'info');
        }
        
        // Setup initial UI states
        document.getElementById('debug-info').style.display = 'none';
        document.getElementById('debug-toggle').textContent = 'Show';
        
        // Start music
        try {
          if (window.parent.AudioManager) {
            window.parent.AudioManager.unmute();
            if (window.parent.AudioManager.gameMusic) {
              window.parent.AudioManager.gameMusic.play();
              log('Game music started', 'info');
            }
          }
        } catch (e) {
          log('Error initializing audio: ' + e.message, 'warn');
        }
        
        // Setup touch controls based on device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
          const touchControlsToggle = document.getElementById('touch-controls-toggle');
          if (touchControlsToggle) {
            touchControlsToggle.textContent = 'Hide';
            // Actually show touch controls on mobile
            const touchControls = document.querySelector('#touch-controls');
            if (touchControls) {
              touchControls.style.display = 'flex';
            }
          }
        }
        
        // Make sure all settings menu buttons work
        const touchControlsToggleBtn = document.getElementById('touch-controls-toggle');
        if (touchControlsToggleBtn) {
          touchControlsToggleBtn.addEventListener('click', function() {
            const touchControls = document.querySelector('#touch-controls');
            if (touchControls) {
              const isVisible = touchControls.style.display === 'flex';
              touchControls.style.display = isVisible ? 'none' : 'flex';
              this.textContent = isVisible ? 'Show' : 'Hide';
            }
          });
        }
        
        try {
          // Log character and mode selection
          log(`Selected mode: ${selectedMode}, character: ${selectedCharacter}`, 'info');
          
          // Create clock for timing
          clock = new THREE.Clock();
          
          // Reset key states
          keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false
          };
          
          // Set jump variables
          isJumping = false;
          jumpTime = 0;
          jumpHeight = 0;
          jumpPressed = false;
          canJump = true;
          
          // Other initialization variables
          debugMode = false;
          frameCount = 0;
          
          log('Setting up Three.js...', 'info');
          
          // Create renderer directly here to avoid reassignment issues
          const gameContainer = document.getElementById('game-container');
          gameContainer.innerHTML = ''; // Clear any previous content
          
          // Enhanced window resize handling for mobile
          function onWindowResize() {
            if (camera && renderer) {
              // Get actual viewport dimensions
              const width = window.innerWidth;
              const height = window.innerHeight;
              
              // Update camera and renderer
              camera.aspect = width / height;
              camera.updateProjectionMatrix();
              renderer.setSize(width, height, true); // true for updateStyle
            }
          }
          window.addEventListener('resize', onWindowResize, false);
          
          // Create and configure renderer
          try {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            gameContainer.appendChild(renderer.domElement);
            log('Renderer created successfully', 'info');
          } catch (e) {
            log('ERROR creating renderer: ' + e.message, 'error');
            console.error('Renderer error:', e);
          }
          
          // Setup scene with the simplest possible environment
          function setupScene() {
            log('Setting up scene...', 'info');
            
            try {
              scene = new THREE.Scene();
              scene.background = new THREE.Color(0x333333); // Medium grey background
              

              // Create camera
              camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
              camera.position.set(0, 3, 5); // Positioned behind cockroach
              

              // Make camera globally accessible for zoom functionality
              window.camera = camera;
              

              // Add lights
              const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
              scene.add(ambientLight);
              

              const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
              directionalLight.position.set(5, 10, 7.5);
              directionalLight.castShadow = true;
              scene.add(directionalLight);
              

              // Set up shadow properties
              directionalLight.shadow.mapSize.width = 1024;
              directionalLight.shadow.mapSize.height = 1024;
              directionalLight.shadow.camera.near = 0.5;
              directionalLight.shadow.camera.far = 50;
              directionalLight.shadow.bias = -0.001;
              

              // Create ground plane
              const planeGeometry = new THREE.PlaneGeometry(100, 100);
              const planeMaterial = new THREE.MeshStandardMaterial({
                color: 0x808080,
                roughness: 0.7,
                metalness: 0.1,
              });
              const plane = new THREE.Mesh(planeGeometry, planeMaterial);
              plane.rotation.x = -Math.PI / 2; // Rotate to be flat
              plane.receiveShadow = true;
              scene.add(plane);
              

              // Add grid for better visual reference
              const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x444444);
              scene.add(gridHelper);
              

              // Initialize camera position
              camera.position.set(0, 3, 5);
              camera.lookAt(0, 0, 0);
              

              log('Scene setup complete', 'info');
            } catch (e) {
              log('ERROR setting up scene: ' + e.message, 'error');
              console.error('Scene setup error:', e);
            }
          }
          setupScene();
          
          // Initialize physics
          initPhysics();
          
          // Load cockroach model
          loadCockroachModel();
          
          // Setup input handlers
          setupInputHandlers();
          
          // Start animation loop
          animate();
          
          log('Game initialization complete', 'info');
          log('========================================', 'info');
          log('Use WASD or arrow keys to move', 'info');
          log('Press SPACE to jump', 'info');
          log('Press T to toggle debug mode', 'info');
          log('========================================', 'info');
          
          // Inform parent we're loaded
          sendLoadedMessage();
          
          return true;
        } catch (error) {
          log(`CRITICAL ERROR during initialization: ${error.message}`, 'error');
          console.error('Game initialization error:', error);
          return false;
        }
      }
      
      // Send message to parent that game is loaded
      function sendLoadedMessage() {
        try {
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({
              type: 'game-loaded',
              status: 'success'
            }, '*');
            log('Sent loaded message to parent', 'info');
          }
        } catch (e) {
          console.error('Error sending loaded message:', e);
        }
      }
      
      // Initialize more realistic physics world
      function initPhysics() {
        log('Initializing physics world...', 'info');
        
        try {
          // Create world with gravity and damping
          world = new CANNON.World();
          world.gravity.set(0, -9.82, 0); // Earth gravity
          world.defaultContactMaterial.friction = 0.2; // Global friction
          world.allowSleep = true; // Allow objects to sleep when inactive (performance)
          world.solver.iterations = 10; // More accurate physics
          
          // Create ground plane with extra friction to prevent sliding
          const groundShape = new CANNON.Plane();
          const groundBody = new CANNON.Body({ mass: 0 }); // Static body
          groundBody.addShape(groundShape);
          groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
          world.addBody(groundBody);
          
          // Create materials with proper physical properties
          try {
            // Ground material (high friction)
            const groundMaterial = new CANNON.Material('groundMaterial');
            groundBody.material = groundMaterial;
            
            // Cockroach material (good grip for climbing)
            const cockroachMaterial = new CANNON.Material('cockroachMaterial');
            
            // Contact behavior between materials
            const contactMaterial = new CANNON.ContactMaterial(
              groundMaterial,
              cockroachMaterial,
              { 
                friction: 0.8, // High friction for better grip
                restitution: 0.2, // Low bounce
                contactEquationStiffness: 1e8, // Firm contact
                contactEquationRelaxation: 3 // Stable contact
              }
            );
            world.addContactMaterial(contactMaterial);
            
            log('Physics materials configured for realistic movement', 'info');
          } catch (e) {
            log("Advanced physics setup failed, using basic settings", 'warn');
            console.warn('Physics setup issue:', e);
          }
          
          log('Physics world initialized successfully', 'info');
        } catch (error) {
          log(`Error initializing physics: ${error.message}`, 'error');
          console.error('Physics initialization error:', error);
        }
      }
      
      // Load cockroach model with faster loading and no delays
      function loadCockroachModel() {
        // Hide loading indicator - we don't need it and it slows things down
        const loadingIndicator = document.getElementById('loading-indicator');
        if (loadingIndicator) {
          loadingIndicator.style.display = 'none';
        }
        
        // Use only the most likely path for faster loading
        const possibleFilenames = [
          'assets/models/American Cockroach.glb',  // Most likely path
          './assets/models/American Cockroach.glb',
          '../assets/models/American Cockroach.glb'
        ];
        
        // Load manager to handle all load attempts
        const loadManager = new THREE.LoadingManager();
        let modelLoaded = false;
        
        // Try each filename in sequence
        function tryNextModel(index) {
          if (index >= possibleFilenames.length) {
            if (!modelLoaded) {
              try {
                if (loadingIndicator && loadingIndicator.parentNode) {
                  loadingIndicator.parentNode.removeChild(loadingIndicator);
                }
              } catch (e) {}
              createPlaceholderCockroach();
            }
            return;
          }
          
          const filename = possibleFilenames[index];
          // Skip logging to improve performance
          
          const loader = new THREE.GLTFLoader(loadManager);
          loader.load(
            filename,
            function(gltf) {
              modelLoaded = true;
              
              // Skip logging to speed up loading
              try {
                if (loadingIndicator && loadingIndicator.parentNode) {
                  loadingIndicator.parentNode.removeChild(loadingIndicator);
                }
              } catch (e) {}
              

              // Store model
              cockroachModel = gltf.scene;
              // Increased scale for better visibility
              cockroachModel.scale.set(0.3, 0.3, 0.3);
              cockroachModel.position.set(0, 0.2, 0); // Raised position slightly
              

              // Make sure model casts shadows
              cockroachModel.traverse(function (child) {
                if (child.isMesh) {
                  child.castShadow = true;
                  child.receiveShadow = true;
                  // Add slight emission to make it more visible in the dark
                  if (child.material) {
                    child.material.emissive = new THREE.Color(0x222222);
                  }
                }
              });
              

              scene.add(cockroachModel);
              

              // Create physics body
              createCockroachPhysics();
              
              // Update cockroach for rendering
              updateCockroach();
              

              log('Cockroach model added to scene', 'info');
            },
            function(xhr) {
              // Update loading progress
              if (xhr.lengthComputable) {
                const percentComplete = Math.round(xhr.loaded / xhr.total * 100);
                loadingIndicator.innerHTML = `Loading ${filename.split('/').pop()}: ${percentComplete}%`;
              }
            },
            function(error) {
              log(`Failed to load ${filename}: ${error.message}`, 'error');
              console.error(`Model load error for ${filename}:`, error);
              // Short delay before trying next path to avoid rate-limiting
              setTimeout(() => tryNextModel(index + 1), 100);
            }
          );
        }
        
        // Start trying models
        tryNextModel(0);
      }
      
      // Create placeholder cockroach when model loading fails
      function createPlaceholderCockroach() {
        log('Creating placeholder cockroach geometry', 'info');
        try {
          // Create a simple placeholder - just a capsule shape
          const geometry = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
          const material = new THREE.MeshBasicMaterial({ color: 0x8B4513 }); // Brown color
          cockroach = new THREE.Mesh(geometry, material);
          cockroach.scale.set(0.15, 0.08, 0.2); // Flatter, more cockroach-like
          cockroach.position.y = 0.1; // Close to ground
          scene.add(cockroach);
          
          cockroachLoaded = true;
          log('Placeholder cockroach created', 'info');
        } catch (error) {
          log(`Error creating placeholder: ${error.message}`, 'error');
          console.error('Placeholder creation error:', error);
          
          // Ultra-simple fallback if all else fails
          try {
            const boxGeometry = new THREE.BoxGeometry(0.5, 0.2, 1);
            const boxMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
            cockroach = new THREE.Mesh(boxGeometry, boxMaterial);
            cockroach.position.y = 0.1;
            scene.add(cockroach);
            cockroachLoaded = true;
          } catch (e) {
            // Last resort - if everything fails
            console.error('Failed to create any cockroach model');
          }
        }
      }
      
      // Create cockroach physics body
      function createCockroachPhysics() {
        if (world && cockroachModel) {
          log('Creating cockroach physics body...', 'info');
          
          try {
            // Create a simple box shape for physics
            const shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.2, 1));
            
            // Create body with mass (non-zero for dynamic object)
            cockroachBody = new CANNON.Body({
              mass: 1,
              position: new CANNON.Vec3(
                cockroachModel.position.x, 
                cockroachModel.position.y, 
                cockroachModel.position.z
              ),
              shape: shape,
              linearDamping: 0.5,  // Add damping to prevent excessive sliding
              angularDamping: 0.8  // Prevent excessive rotation
            });
            
            // Add to world
            world.addBody(cockroachBody);
            log('Physics body created successfully', 'info');
          } catch (error) {
            log(`Error creating physics body: ${error.message}`, 'error');
            console.error('Physics body creation error:', error);
          }
        } else {
          log('Cannot create physics body: world or model missing', 'error');
        }
      }
      
      // Enhanced input handlers for better responsiveness
      function setupInputHandlers() {
        // Reset key states to avoid conflicts with global declaration
        keys = {
          forward: false,
          backward: false,
          left: false,
          right: false,
          jump: false,
          zoomIn: false,
          zoomOut: false
        };
        
        // Track pressed keys with keyCode fallbacks for maximum compatibility
        const keyCodes = {
          // Forward
          87: 'forward',    // W
          38: 'forward',    // Arrow Up
          // Backward
          83: 'backward',   // S
          40: 'backward',   // Arrow Down
          // Left
          65: 'left',       // A
          37: 'left',       // Arrow Left
          // Right
          68: 'right',      // D
          39: 'right',      // Arrow Right
          // Jump
          32: 'jump',       // Space
          // Zoom controls
          70: 'zoomIn',     // F
          71: 'zoomOut'     // G
        };
        
        // Event handler - keydown with maximum compatibility
        window.addEventListener('keydown', function(event) {
          // Prevent default for arrow keys and space
          if ([32, 37, 38, 39, 40].includes(event.keyCode)) {
            event.preventDefault();
          }
          
          // Handle through keyCode (most compatible approach)
          const action = keyCodes[event.keyCode];
          if (action) {
            // Special handling for jump to prevent continuous jumping
            if (action === 'jump') {
              if (!jumpPressed && canJump) {
                keys.jump = true;
                jumpPressed = true;
                log('Jump key pressed - initiating jump', 'input');
              }
            } else if (!keys[action]) {
              // Normal handling for movement keys
              keys[action] = true;
              
              // Only log if this is a new key
              log(`Key pressed: ${event.code || event.keyCode}`, 'input');
            }
            
            // Force immediate movement update for responsiveness
            updateCockroach();
          }
          
          // Toggle debug mode (T key = 84)
          if (event.keyCode === 84) {
            debugMode = !debugMode;
            if (debugMode) {
              orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
              log('Debug mode enabled (orbit controls)', 'info');
            } else {
              if (orbitControls) {
                orbitControls.dispose();
                orbitControls = null;
              }
              log('Debug mode disabled', 'info');
            }
          }
        });
        
        // Event handler - keyup with similar compatibility approach
        window.addEventListener('keyup', function(event) {
          // Handle through keyCode (most compatible approach)
          const action = keyCodes[event.keyCode];
          if (action) {
            if (action === 'jump') {
              // Reset jump key state and pressed tracking
              keys.jump = false;
              jumpPressed = false;
              log('Jump key released', 'input');
            } else {
              // Normal handling for movement keys
              keys[action] = false;
            }
          }
        });
        
        // Add click handler to ensure focus
        const gameContainer = document.getElementById('game-container');
        gameContainer.addEventListener('click', function() {
          log('Game area clicked, ensuring focus', 'info');
          // Add visible indicator for keyboard focus
          gameContainer.style.outline = '2px solid #888888';
          setTimeout(() => {
            gameContainer.style.outline = 'none';
          }, 500);
        });
        
        // Add touch controls for mobile/tablet support
        addTouchControls();
        
        log('Enhanced input handlers set up with cross-browser compatibility', 'info');
      }
      
      // Add touch controls for mobile devices
      function addTouchControls() {
        const container = document.getElementById('game-container');
        
        // Create touch overlay
        const touchControls = document.createElement('div');
        touchControls.id = 'touch-controls';
        touchControls.style.position = 'fixed';
        touchControls.style.bottom = '20px';
        touchControls.style.left = '50%';
        touchControls.style.transform = 'translateX(-50%)';
        touchControls.style.display = 'none'; // Hidden by default
        touchControls.style.flexWrap = 'wrap';
        touchControls.style.justifyContent = 'center';
        touchControls.style.gap = '5px';
        touchControls.style.zIndex = '1000';
        touchControls.style.maxWidth = '100%';
        touchControls.style.padding = '5px';
        
        // Create touch buttons with simple style but improved responsiveness
        const createButton = (text, key) => {
          const btn = document.createElement('button');
          btn.textContent = text;
          btn.style.backgroundColor = 'rgba(80, 80, 80, 0.7)';
          btn.style.color = '#ffffff';
          btn.style.border = '1px solid #888888';
          btn.style.borderRadius = '5px';
          btn.style.fontSize = '24px';
          btn.style.padding = '15px';
          btn.style.margin = '5px';
          btn.style.minWidth = '60px';
          btn.style.minHeight = '60px';
          btn.style.touchAction = 'manipulation';
          
          // Handle touch events for mobile
          btn.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent zooming
            keys[key] = true;
            log(`Touch control: ${text}`, 'input');
          });
          
          btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys[key] = false;
          });
          
          // Also handle mouse events for testing on desktop
          btn.addEventListener('mousedown', () => {
            keys[key] = true;
          });
          
          btn.addEventListener('mouseup', () => {
            keys[key] = false;
          });
          
          btn.addEventListener('mouseleave', () => {
            keys[key] = false;
          });
          
          return btn;
        };
        
        // Create directional buttons
        const upBtn = createButton('', 'forward');
        const downBtn = createButton('', 'backward');
        const leftBtn = createButton('', 'left');
        const rightBtn = createButton('', 'right');
        
        // Create jump button
        const jumpBtn = createButton('JUMP', 'jump');
        jumpBtn.style.width = '120px';
        
        // Add buttons to container
        touchControls.appendChild(upBtn);
        touchControls.appendChild(document.createElement('br'));
        touchControls.appendChild(leftBtn);
        touchControls.appendChild(downBtn);
        touchControls.appendChild(rightBtn);
        touchControls.appendChild(document.createElement('br'));
        touchControls.appendChild(jumpBtn);
        
        // Add to page
        document.body.appendChild(touchControls);
        
        // Check if mobile and initialize touch button state
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
          // Set initial state for settings button
          document.getElementById('touch-controls-toggle').textContent = 'Hide';
          touchControls.style.display = 'flex';
          log('Mobile device detected - touch controls enabled', 'info');
        } else {
          document.getElementById('touch-controls-toggle').textContent = 'Show';
          log('Desktop detected - touch controls hidden by default', 'info');
        }
        
        // Set up toggle button functionality
        document.getElementById('touch-controls-toggle').addEventListener('click', function() {
          if (touchControls.style.display === 'none') {
            touchControls.style.display = 'flex';
            this.textContent = 'Hide';
          } else {
            touchControls.style.display = 'none';
            this.textContent = 'Show';
          }
        });
        
        // SFX toggle button
        document.getElementById('sfx-toggle').addEventListener('click', function() {
          try {
            // First try the local AudioManager we've added
            if (window.AudioManager) {
              const audioManager = window.AudioManager;
              
              // Toggle SFX volume
              audioManager.sfxVolume = audioManager.sfxVolume > 0 ? 0 : 1.0;
              audioManager.applyVolumeSettings();
              localStorage.setItem('sfxVolume', audioManager.sfxVolume);
              
              // Update button text
              this.textContent = audioManager.sfxVolume > 0 ? 'On' : 'Off';
              log('Sound effects turned ' + (audioManager.sfxVolume > 0 ? 'on' : 'off'), 'info');
            } 
            // Fallback to parent window
            else {
              // Visual toggle
              this.textContent = this.textContent === 'On' ? 'Off' : 'On';
              
              // Send message to parent window
              window.parent.postMessage({ type: 'toggle-sfx' }, '*');
            }
          } catch (e) {
            // Visual toggle as fallback
            this.textContent = this.textContent === 'On' ? 'Off' : 'On';
            log('Error toggling SFX: ' + e.message, 'error');
          }  
        });
      }
      
      // SIMPLE and DIRECT cockroach movement with no complex timing logic
      function updateCockroach() {
        if (!cockroachModel) return;
        
        // MOVEMENT PARAMETERS with realistic physics
        const MOVE_SPEED = 0.25; // Base movement speed
        const ROTATE_SPEED = 0.08; // Base rotation speed
        const ACCELERATION = 0.01; // How quickly the cockroach speeds up
        const DECELERATION = 0.95; // How quickly it slows down (friction)
        const MAX_SPEED = 0.4; // Maximum movement speed
        
        // Keep track of current velocity
        cockroachModel.userData.velocity = cockroachModel.userData.velocity || {
          forward: 0,
          rotation: 0
        }
        
        // Track if any movement occurred
        let moved = false;
        
        // REALISTIC MOVEMENT with acceleration/deceleration
        
        // FORWARD/BACKWARD MOVEMENT with acceleration
        if (keys.forward) {
          // Accelerate forward up to max speed
          cockroachModel.userData.velocity.forward += ACCELERATION;
          if (cockroachModel.userData.velocity.forward > MAX_SPEED) {
            cockroachModel.userData.velocity.forward = MAX_SPEED;
          }
          moved = true;
        } else if (keys.backward) {
          // Accelerate backward up to max speed
          cockroachModel.userData.velocity.forward -= ACCELERATION;
          if (cockroachModel.userData.velocity.forward < -MAX_SPEED * 0.7) { // Cockroaches are slower backward
            cockroachModel.userData.velocity.forward = -MAX_SPEED * 0.7;
          }
          moved = true;
        } else {
          // Decelerate when no forward/backward key is pressed
          cockroachModel.userData.velocity.forward *= DECELERATION;
          
          // Stop completely if very slow (avoid endless tiny movements)
          if (Math.abs(cockroachModel.userData.velocity.forward) < 0.01) {
            cockroachModel.userData.velocity.forward = 0;
          }
        }
        
        // Apply forward/backward movement
        if (cockroachModel.userData.velocity.forward !== 0) {
          cockroachModel.translateZ(cockroachModel.userData.velocity.forward);
          moved = true;
        }
        
        // LEFT/RIGHT ROTATION with momentum
        if (keys.left) {
          // Increase rotation velocity (left)
          cockroachModel.userData.velocity.rotation += ACCELERATION * 2;
          if (cockroachModel.userData.velocity.rotation > ROTATE_SPEED) {
            cockroachModel.userData.velocity.rotation = ROTATE_SPEED;
          }
          moved = true;
        } else if (keys.right) {
          // Increase rotation velocity (right)
          cockroachModel.userData.velocity.rotation -= ACCELERATION * 2;
          if (cockroachModel.userData.velocity.rotation < -ROTATE_SPEED) {
            cockroachModel.userData.velocity.rotation = -ROTATE_SPEED;
          }
          moved = true;
        } else {
          // Decelerate rotation when no left/right key is pressed
          cockroachModel.userData.velocity.rotation *= DECELERATION;
          
          // Stop rotating if very slow
          if (Math.abs(cockroachModel.userData.velocity.rotation) < 0.005) {
            cockroachModel.userData.velocity.rotation = 0;
          }
        }
        
        // Apply rotation
        if (cockroachModel.userData.velocity.rotation !== 0) {
          cockroachModel.rotation.y += cockroachModel.userData.velocity.rotation;
          moved = true;
        }
        
        // Add slight body tilt when turning (more realistic)
        if (cockroachModel.userData.velocity.rotation !== 0) {
          // Lean into turns
          const targetTilt = -cockroachModel.userData.velocity.rotation * 2;
          cockroachModel.rotation.z = targetTilt;
        } else {
          // Return to level when not turning
          cockroachModel.rotation.z *= 0.8;
        }
        
        // JUMPING (Spacebar) with single-press logic and cooldown
        if (keys.jump && !isJumping && canJump) {
          isJumping = true;
          jumpTime = 0;
          jumpHeight = cockroachModel.position.y;
          canJump = false; // Prevent new jumps until this one completes
          keys.jump = false; // Immediately reset jump key to prevent multiple jumps
          console.log('Jump initiated'); // Debug log
        }
        
        // Realistic jumping with acceleration and landing
        if (isJumping) {
          // More realistic jump curve with fast rise and slower fall
          jumpTime += 0.1;
          
          // Calculate jump height using a custom curve for more realistic movement
          let jumpCurve;
          if (jumpTime < Math.PI/2) {
            // Quick upward movement (0 to /2)
            jumpCurve = Math.sin(jumpTime) * 1.2;
          } else {
            // Slower fall (/2 to )
            jumpCurve = Math.sin(jumpTime) * 0.8;
          }
          
          // Apply jump height
          cockroachModel.position.y = jumpHeight + jumpCurve;
          
          // End jump at end of cycle
          if (jumpTime >= Math.PI) {
            isJumping = false;
            cockroachModel.position.y = jumpHeight;
            canJump = true; // Re-enable jumping after landing
            console.log('Jump completed, can jump again'); // Debug log
            
            // Add a slight forward impulse on landing (cockroaches often jump forward)
            if (cockroachModel.userData.velocity.forward >= 0) {
              cockroachModel.userData.velocity.forward += 0.05;
            }
          }
          
          moved = true;
        }
        
        // BOUNDARY LIMITS
        const maxBounds = 20;
        cockroachModel.position.x = Math.max(-maxBounds, Math.min(maxBounds, cockroachModel.position.x));
        cockroachModel.position.z = Math.max(-maxBounds, Math.min(maxBounds, cockroachModel.position.z));
        
        // Keep above ground
        if (cockroachModel.position.y < 0.2) {
          cockroachModel.position.y = 0.2;
        }
        
        // Update physics if needed
        if (moved && cockroachBody) {
          cockroachBody.position.copy(cockroachModel.position);
          cockroachBody.quaternion.copy(cockroachModel.quaternion);
          
          // Log occasionally
          if (frameCount % 60 === 0) {
            console.log(`Position: ${cockroachModel.position.x.toFixed(1)}, ${cockroachModel.position.y.toFixed(1)}, ${cockroachModel.position.z.toFixed(1)}`);
          }
        }
        
        return moved;
      }
      
      // Frame count is defined in global variables at the top
      // Notify parent window of significant movement
      function notifyParentOfMovement() {
        try {
          if (window.parent && window.parent !== window) {
            window.parent.postMessage({
              type: 'cockroach-moved',
              position: {
                x: cockroachModel.position.x,
                y: cockroachModel.position.y,
                z: cockroachModel.position.z
              }
                        }, '*');
          }
        } catch (e) {
          // Ignore cross-origin errors
        }
      }
      
      // Jump state is tracked in global variables
      // initialized at the top of the script
      // Update camera to follow cockroach with improved tracking
      function updateCamera() {
        if (!camera || !cockroachModel) return;
        
        // Camera settings
        const distance = 5;  // Distance behind cockroach
        const height = 3;    // Height above cockroach
        const lookOffset = 2; // Look slightly ahead of cockroach
        
        // Handle zoom controls
        if (keys.zoomIn) {
          // Zoom in (reduce FOV)
          currentFOV = Math.max(minFOV, currentFOV - zoomStep * 0.1);
          camera.fov = currentFOV;
          camera.updateProjectionMatrix();
          log('Zoom key pressed: zoomIn', 'input');
        }
        
        if (keys.zoomOut) {
          // Zoom out (increase FOV)
          currentFOV = Math.min(maxFOV, currentFOV + zoomStep * 0.1);
          camera.fov = currentFOV;
          camera.updateProjectionMatrix();
          log('Zoom key pressed: zoomOut', 'input');
        }
        
        // Calculate target position behind cockroach
        const targetX = cockroachModel.position.x - Math.sin(cockroachModel.rotation.y) * distance;
        const targetZ = cockroachModel.position.z - Math.cos(cockroachModel.rotation.y) * distance;
        const targetY = cockroachModel.position.y + height;
        
        // Calculate point to look at (slightly ahead of cockroach)
        const lookAtX = cockroachModel.position.x + Math.sin(cockroachModel.rotation.y) * lookOffset;
        const lookAtZ = cockroachModel.position.z + Math.cos(cockroachModel.rotation.y) * lookOffset;
        const lookAtY = cockroachModel.position.y + 0.5; // Slightly above cockroach
        
        // Smooth camera movement based on cockroach velocity
        // Faster follow when cockroach is moving quickly
        const speedFactor = Math.abs(cockroachModel.userData.velocity.forward) * 2;
        const followSpeed = 0.05 + speedFactor * 0.1; // 0.05 to 0.15 based on speed
        
        // Apply smooth camera movement
        camera.position.x += (targetX - camera.position.x) * followSpeed;
        camera.position.z += (targetZ - camera.position.z) * followSpeed;
        camera.position.y += (targetY - camera.position.y) * followSpeed;
        
        // Look ahead of cockroach (makes turns look better)
        camera.lookAt(new THREE.Vector3(lookAtX, lookAtY, lookAtZ));
      }
      
      // SIMPLE animation loop - no complex timing logic
      function animate() {
        requestAnimationFrame(animate);
        
        try {
          // Increment frame counter
          frameCount++;
          
          // Simple physics update if needed
          if (world) {
            world.step(1/60);
          }
          
          // Update debug controls if active
          if (debugMode && orbitControls) {
            orbitControls.update();
          }
          
          // Update cockroach position with simple movement
          updateCockroach();
          
          // Update camera
          updateCamera();
          
          // Render
          if (renderer && scene && camera) {
            renderer.render(scene, camera);
          }
        } catch (error) {
          console.error('Animation error:', error);
        }
      }
      
      // Game will initialize when window loads through the onload handler
      
      // Listen for messages from parent window
      window.addEventListener('message', function(event) {
        // Handle messages from parent
        const message = event.data;
        
        // Handle new message types first
        if (message.type) {
          if (message.type === 'set-mode') {
            // Parent is telling us which mode to use
            log(`Parent set mode: ${message.mode}`, 'info');
            return;
          }
          
          if (message.type === 'set-character') {
            // Parent is telling us which character to use
            log(`Parent set character: ${message.character}`, 'info');
            return;
          }
          
          if (message.type === 'set-audio-context') {
            // Parent is telling us which audio context to use (menu or game)
            const isGameContext = message.context === 'game';
            const forceStopMenuMusic = message.forceStopMenuMusic === true;
            log(`Parent set audio context: ${message.context.toUpperCase()} (force stop: ${forceStopMenuMusic})`, 'info');
            
            // EMERGENCY MUSIC SHUTDOWN - Stop ALL audio playing in the document
            const allAudioElements = document.querySelectorAll('audio');
            log(`Stopping all ${allAudioElements.length} audio elements before context change`, 'warning');
            
            allAudioElements.forEach(audio => {
              if (!audio.paused) {
                log(`Forcefully stopping audio: ${audio.id || 'unnamed'}`, 'info');
                try {
                  audio.pause();
                  audio.currentTime = 0;
                } catch (e) {
                  log(`Error stopping audio: ${e.message}`, 'error');
                }
              }
            });
            
            // Delay before starting new context to ensure clean transition
            setTimeout(() => {
              // Update AudioManager context if available
              if (window.AudioManager) {
                // Reset all tracks to make sure we start fresh
                if (window.AudioManager.menuMusic) {
                  log('Resetting menu music', 'info');
                  window.AudioManager.menuMusic.pause();
                  window.AudioManager.menuMusic.currentTime = 0;
                }
                
                if (window.AudioManager.gameMusic) {
                  log('Resetting game music', 'info');
                  window.AudioManager.gameMusic.pause();
                  window.AudioManager.gameMusic.currentTime = 0;
                }
                
                // Set the context (this will trigger appropriate music)
                log(`Setting AudioManager context to: ${isGameContext ? 'GAME' : 'MENU'}`, 'info');
                window.AudioManager.setContext(isGameContext);
                
                // Explicitly play game music to ensure it starts, but only after a short delay
                if (isGameContext) {
                  setTimeout(() => {
                    log('Forcing game music to play after context change', 'info');
                    window.AudioManager.playMusicInGameContext();
                    
                    // Update the now playing indicator
                    const nowPlaying = document.getElementById('now-playing');
                    const nowPlayingText = document.getElementById('now-playing-text');
                    const musicTrackButton = document.getElementById('music-track-button');
                    
                    if (nowPlaying && nowPlayingText && musicTrackButton) {
                      const gameTrack = window.AudioManager.gameTrackId;
                      const trackElement = document.querySelector(`.track-option[data-value="${gameTrack}"]`);
                      if (trackElement) {
                        musicTrackButton.textContent = trackElement.textContent;
                        nowPlayingText.textContent = trackElement.textContent;
                        nowPlaying.style.display = 'block';
                      }
                    }
                  }, 1000); // Longer delay to ensure clean transition
                }
              }
            }, 200); // Short delay to ensure all audio is properly stopped
          }
          return;
        }
        
        // Handle legacy message format with action property
        if (message.action) {
          log(`Received message from parent: ${message.action}`);
          
          switch(message.action) {
            case 'focus':
              // Focus this window
              window.focus();
              log('Window focused');
              break;
            case 'pause':
              // Pause game logic
              isRunning = false;
              log('Game paused');
              break;
            case 'resume':
              // Resume game logic
              isRunning = true;
              log('Game resumed');
              break;
            case 'keypress':
              // Simulate a keypress from parent
              log(`Received keypress: ${message.key}`);
              break;
          }
        }
      });
      
      // Tell parent window we're loaded
      if (window.parent && window.parent !== window) {
        window.parent.postMessage({ type: 'game-loaded' }, '*');
        log('Sent loaded message to parent');
      }
      
    })();
  </script>
</body>
</html>
