<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cockroach Run - Free World Test</title>
  
  <!-- Message remover script, loads first to immediately remove unwanted elements -->
  <script src="message-remover.js"></script>
  
  <script>
    // EXTREMELY aggressive removal of any focus messages
    (function permanentlyRemoveAllMessages() {
      function removeMessages() {
        try {
          // Target any focus/click messages by various attributes
          const selectors = [
            'div[style*="color: rgb(0, 255, 102)"]', 
            'div[style*="color: #00FF66"]',
            'div[style*="color:#00FF66"]',
            'div[style*="bottom: 10px; right: 10px"]',
            'div[data-component-name="<div />"]',
            'div[style*="monospace"]'
          ];
          
          // Find by selectors
          document.querySelectorAll(selectors.join(',')).forEach(el => {
            if (el && el.parentNode) el.parentNode.removeChild(el);
          });
          
          // Find by text content
          document.querySelectorAll('div').forEach(el => {
            if (el && el.textContent && 
                (el.textContent.includes('Click in the game') || 
                 el.textContent.includes('enable controls'))) {
              if (el.parentNode) el.parentNode.removeChild(el);
            }
          });
        } catch(e) {}
      }
      
      // Run now and periodically
      removeMessages();
      setInterval(removeMessages, 300);
      
      // Also run on any DOM changes
      const observer = new MutationObserver(function(mutations) {
        removeMessages();
      });
      
      // Start observing when DOM is ready
      document.addEventListener('DOMContentLoaded', function() {
        observer.observe(document.body, { childList: true, subtree: true });
        removeMessages();
      });
    })();
  </script>
  <!-- Load Three.js libraries from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <!-- Load Cannon.js physics engine (using original Cannon for direct script tag compatibility) -->
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #121212;
      color: #00FF66;
      font-family: 'Orbitron', sans-serif;
    }
    
    /* Key indicator for visual feedback */
    #key-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: grid;
      grid-template-areas:
        ". up ."
        "left down right";
      grid-gap: 5px;
      z-index: 1000;
      pointer-events: none;
    }
    
    #game-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      box-sizing: border-box;
      border: 3px dashed #9333EA;
      z-index: 10;
      outline: none; /* Remove outline when focused */
      cursor: pointer; /* Show pointer cursor */
    }
    
    #focus-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      color: #00FF66;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      cursor: pointer;
      font-size: 24px;
      text-shadow: 0 0 10px #9333EA;
    }
    #game-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #121212;
    }
    
    #instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: #00FF66;
      padding: 10px;
      border: 1px solid #00FF66;
      border-radius: 5px;
      z-index: 1000;
      pointer-events: none;
      user-select: none;
      max-width: 300px;
    }
    
    #character-selector {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: #00FF66;
      padding: 10px;
      border: 1px solid #00FF66;
      border-radius: 5px;
      z-index: 1000;
    }
    
    button {
      background-color: #9333EA;
      color: white;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 3px;
      font-family: 'Exo 2', sans-serif;
      margin: 5px;
    }
    
    button:hover {
      background-color: #7B2AC5;
    }
  </style>
</head>
<body>
  <div id="game-container" tabindex="0">
    <canvas id="game-canvas"></canvas>
    <div id="focus-overlay">
      <h2>CLICK TO START</h2>
      <p>Click anywhere to gain focus and enable keyboard controls</p>
      <div style="margin-top: 20px; border: 2px solid #00FF66; padding: 10px; max-width: 80%; text-align: center;">
        <p style="margin: 5px 0;">Use WASD or ARROW KEYS to move</p>
        <p style="margin: 5px 0;">SPACE to jump</p>
        <p style="margin: 5px 0;">Movement is a bit slow but should definitely work!</p>
      </div>
    </div>
    
    <!-- Visual key indicators -->
    <div id="key-indicator" style="display: none;">
      <div id="key-up" style="grid-area: up; width: 50px; height: 50px; background-color: rgba(0,255,102,0.2); border: 2px solid #00FF66; text-align: center; line-height: 50px;">W</div>
      <div id="key-left" style="grid-area: left; width: 50px; height: 50px; background-color: rgba(0,255,102,0.2); border: 2px solid #00FF66; text-align: center; line-height: 50px;">A</div>
      <div id="key-down" style="grid-area: down; width: 50px; height: 50px; background-color: rgba(0,255,102,0.2); border: 2px solid #00FF66; text-align: center; line-height: 50px;">S</div>
      <div id="key-right" style="grid-area: right; width: 50px; height: 50px; background-color: rgba(0,255,102,0.2); border: 2px solid #00FF66; text-align: center; line-height: 50px;">D</div>
    </div>

    <!-- Zoom Controls -->
    <div id="zoom-controls" style="position: absolute; bottom: 80px; right: 10px; z-index: 1001; display: flex; flex-direction: column;">
      <button id="zoom-in" style="width: 50px; height: 50px; margin-bottom: 5px; background-color: rgba(255,136,0,0.7); border: 2px solid #FF8800; color: #000000; font-size: 24px; line-height: 46px; text-align: center; padding: 0; border-radius: 0;">+</button>
      <button id="zoom-out" style="width: 50px; height: 50px; background-color: rgba(255,136,0,0.7); border: 2px solid #FF8800; color: #000000; font-size: 24px; line-height: 46px; text-align: center; padding: 0; border-radius: 0;">-</button>
    </div>
  </div>
  
  <div id="instructions">
    <h3>Controls:</h3>
    <p>W/Up Arrow - Move Forward</p>
    <p>S/Down Arrow - Move Backward</p>
    <p>A/Left Arrow - Rotate Left</p>
    <p>D/Right Arrow - Rotate Right</p>
    <p>T - Toggle Debug Camera Mode</p>
    <div id="position-display" style="margin-top: 10px; background: rgba(0,0,0,0.7); padding: 5px; color: #00FF66;">
      Position: waiting for movement...
    </div>
  </div>
  
  <div id="character-selector">
    <button id="american-roach">American Cockroach</button>
    <button id="oriental-roach">Oriental Cockroach</button>
  </div>

  <script>
    // For direct movement (no physics)
    let lastUpdateTime = 0;
    
    // Basic game engine
    class Game {
      constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.canvas = null;
        this.clock = new THREE.Clock();
        this.activeMode = null;
        this.selectedCharacter = 'american'; // Default
        this.physicsWorld = null; // Physics world
        this.physicsBodies = []; // Track physics bodies
        
        // Initialize
        this.canvas = document.getElementById('game-canvas');
        this.renderer = new THREE.WebGLRenderer({
          canvas: this.canvas,
          antialias: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x121212);
        
        this.camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        
        // Initialize physics world
        this.initPhysicsWorld();
        
        // Handle window resize
        this.setupResizeHandler();
        
        // Add basic lighting
        this.setupBasicLighting();
      }
      
      initPhysicsWorld() {
        // Create physics world with Earth gravity
        this.physicsWorld = new CANNON.World();
        this.physicsWorld.gravity.set(0, -9.82, 0);
        
        // Configure solver iterations for stability
        this.physicsWorld.solver.iterations = 10;
        
        // Set default material properties
        const defaultMaterial = new CANNON.Material('default');
        const defaultContactMaterial = new CANNON.ContactMaterial(
          defaultMaterial,
          defaultMaterial,
          {
            friction: 0.3,
            restitution: 0.2
          }
        );
        this.physicsWorld.addContactMaterial(defaultContactMaterial);
        
        // Create a ground plane
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({
          mass: 0 // Static body
        });
        groundBody.addShape(groundShape);
        groundBody.material = defaultMaterial;
        
        // Rotate ground to be horizontal (X rotation by -90 degrees)
        const quaternion = new CANNON.Quaternion();
        quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        groundBody.quaternion.copy(quaternion);
        
        // Add ground to world
        this.physicsWorld.addBody(groundBody);
        this.physicsBodies.push(groundBody);
        
        console.log('Physics world initialized');
      }
      
      setupResizeHandler() {
        window.addEventListener('resize', () => {
          const width = this.container.offsetWidth;
          const height = this.container.offsetHeight;
          this.renderer.setSize(width, height, false);
          this.camera.aspect = width / height;
          this.camera.updateProjectionMatrix();
        });
      }
      
      setupBasicLighting() {
        // Ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); // Brighter ambient
        this.scene.add(ambientLight);
        
        // Directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2); // Stronger directional
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        
        // Configure shadow properties
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        
        this.scene.add(directionalLight);
      }
      
      startGame(mode, character) {
        this.selectedCharacter = character;
        this.isRunning = true;
        
        // Initialize Free World mode
        if (mode === 'free-world') {
          this.activeGameMode = new FreeWorldMode(this);
          this.activeGameMode.init();
          
          // Start game loop
          this.gameLoop();
        }
      }
      
      gameLoop() {
        // Get delta time
        const delta = this.clock.getDelta();
        
        // Clamp delta to avoid large physics jumps
        const fixedDelta = Math.min(delta, 0.1);
        
        // Step the physics world simulation
        if (this.physicsWorld) {
          this.physicsWorld.step(1/60, fixedDelta, 3);
        }
        
        // Update game state if running
        if (this.isRunning && this.activeGameMode) {
          this.activeGameMode.update(delta);
        }
        
        // Render the scene
        this.renderer.render(this.scene, this.camera);
        
        // Call next frame
        requestAnimationFrame(this.gameLoop.bind(this));
      }
    }
    
    // Free World Mode
    class FreeWorldMode {
      constructor(game) {
        this.game = game;
        this.objects = [];
        this.clock = new THREE.Clock();
        this.cockroachModel = null; // Visual model
        this.cockroachBody = null;  // Physics body - NEW!
        this.isModelLoaded = false;
        this.mixer = null;
        this.animations = {};
        
        // Movement properties
        this.moveSpeed = 2;
        this.rotationSpeed = 2;
        
        // Input state
        this.keys = {
          forward: false,
          backward: false,
          left: false,
          right: false,
          jump: false
        };
        
        // Camera following
        this.cameraOffset = new THREE.Vector3(0, 3, 5);  // Base offset (Y and Z will be adjusted by zoom)
        this.cameraTarget = new THREE.Vector3(0, 0.5, 0);  // Looking at a point slightly above ground
        this.zoomLevel = 5; // Initial zoom distance (matches initial Z offset)
        this.minZoom = 1.5; // Closest zoom
        this.maxZoom = 15;  // Furthest zoom
        this.zoomSpeed = 0.5; // How much each scroll/click changes zoom
        
        // Debugging
        this.debugMode = false; // Set to false to enable camera following/zoom
      }
    
      init() {
        console.log('Initializing Free World mode');
        
        // Create scene, lights, and initial setup
        this.setupScene();
        
        // Create cockroach character
        this.createCharacter();
        
        // Create environment
        this.createEnvironment();
        
        // Setup input handlers
        this.setupInputHandlers();
        
        // For debugging
        this.addHelpers();
        
        // Add direct movement variables
        this.isJumping = false;
        this.jumpTime = 0;
        
        return this;
      }
      
      setupScene() {
        // Get reference to Three.js components
        this.scene = this.game.scene;
        this.camera = this.game.camera;
        this.renderer = this.game.renderer;
        
        // Set a cyberpunk background color
        this.scene.background = new THREE.Color(0x121212);
        
        // Position camera initially
        this.camera.position.set(0, 3, 8); // Standardized for all modes (adjust as per UI baseline)
        this.camera.lookAt(0, 0, 0);
        
        // Add cyberpunk accent lights
        this.addLights();
      }
      
      addLights() {
        // Add cyberpunk-style accent lights
        const purpleLight = new THREE.PointLight(0x9333EA, 1, 10);
        purpleLight.position.set(-5, 1, 0);
        this.scene.add(purpleLight);
        
        const greenLight = new THREE.PointLight(0x00FF66, 1, 10);
        greenLight.position.set(5, 1, 0);
        this.scene.add(greenLight);
      }
    
      createEnvironment() {
        // Create a simple ground plane
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshStandardMaterial({
          color: 0x333333, // Standard ground color per PRD
          roughness: 0.8,
          metalness: 0.2
        });
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
        ground.receiveShadow = true;
        this.scene.add(ground);
        
        // Add a few simple obstacles to test collision/movement
        this.addObstacle(-5, 0.5, -5, 1, 1, 1, 0x9333EA); // Purple box
        this.addObstacle(5, 0.5, -3, 1, 1, 1, 0x00FF66);  // Green box
      }
      
      addObstacle(x, y, z, width, height, depth, color) {
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshStandardMaterial({
          color: color,
          roughness: 0.7,
          metalness: 0.3
        });
        
        const obstacle = new THREE.Mesh(geometry, material);
        obstacle.position.set(x, y, z);
        obstacle.castShadow = true;
        obstacle.receiveShadow = true;
        
        this.scene.add(obstacle);
        this.objects.push(obstacle);
        
        return obstacle;
      }
    
      createCharacter() {
        const selectedCharacter = this.game.selectedCharacter || 'american';
        
        // Try both model paths with fallbacks
        const modelPaths = [
          'assets/models/cockroach.glb',
          'assets/models/American Cockroach.glb',
          'assets/models/Oriental cockroach.glb',
          'assets/models/default-roach.glb',
          // Add variations with different casing
          'assets/models/Cockroach.glb',
          'assets/models/american_cockroach.glb', 
          'assets/models/oriental_cockroach.glb'
        ];
        
        console.log(`Trying to load cockroach model from multiple paths...`);
        
        // Create a placeholder while the model loads
        this.createPlaceholderCockroach();
        // Ensure placeholder is used as cockroachModel so controls work
        this.cockroachModel = this.placeholder;
        
        // Load the actual model if GLTFLoader is available
        if (typeof THREE.GLTFLoader !== 'undefined') {
          console.log('GLTFLoader is available, trying models...');
          const loader = new THREE.GLTFLoader();
          
          // Try loading models in sequence
          this.tryLoadModels(loader, modelPaths, 0);
        } else {
          console.warn('THREE.GLTFLoader is not available. Using placeholder cockroach only.');
        }
      },
      
      // Try loading models sequentially with fallbacks
      tryLoadModels(loader, paths, index) {
        if (index >= paths.length) {
          console.warn('Failed to load any cockroach model. Using placeholder.');
          return;
        }
        
        const modelPath = paths[index];
        console.log(`Trying model path ${index+1}/${paths.length}: ${modelPath}`);
        
        loader.load(
          modelPath,
            (gltf) => {
              console.log('Model loaded successfully:', gltf);
              
              // Remove placeholder when the real model is loaded
              if (this.placeholder) {
                this.scene.remove(this.placeholder);
                this.placeholder = null;
              }
              
              console.log('Successfully loaded model from:', modelPath);
              
              // Process the loaded model
              this.cockroachModel = gltf.scene;
              this.cockroachModel.traverse(node => {
                if (node.isMesh) {
                  node.castShadow = true;
                  node.receiveShadow = true;
                }
              });
              
              // Scale and position the model appropriately
              this.cockroachModel.scale.set(0.1, 0.1, 0.1);
              
              // Keep track of the current placeholder position
              if (this.placeholder) {
                // Copy position from placeholder
                this.cockroachModel.position.copy(this.placeholder.position);
                this.cockroachModel.rotation.copy(this.placeholder.rotation);
              } else {
                // Default position
                this.cockroachModel.position.set(0, 0.2, 0);
              }
              
              // Log position for debugging
              console.log('Cockroach model positioned at:', this.cockroachModel.position);
              
              // Add to scene
              this.scene.add(this.cockroachModel);
              
              // Do NOT create physics body - direct control only
              
              // Setup animations if any
              if (gltf.animations && gltf.animations.length > 0) {
                this.mixer = new THREE.AnimationMixer(this.cockroachModel);
                
                gltf.animations.forEach(clip => {
                  const name = clip.name.toLowerCase();
                  this.animations[name] = this.mixer.clipAction(clip);
                  
                  // Play idle animation by default
                  if (name.includes('idle')) {
                    this.animations[name].play();
                  }
                });
              }
              
              this.isModelLoaded = true;
            },
            (xhr) => {
              console.log(`Loading model: ${(xhr.loaded / (xhr.total || 1)) * 100}% loaded`);
            },
            (error) => {
              console.log(`Failed to load model from path: ${modelPath}`, error);
              // Try next model path
              this.tryLoadModels(loader, paths, index + 1);
            }
          );
        } else {
          console.warn('THREE.GLTFLoader is not available. Using placeholder cockroach only.');
          // Always create placeholder cockroach if model is not available
          this.createPlaceholderCockroach();
          // IMPORTANT: Set cockroachModel to placeholder, so the rest of the code works the same way
          this.cockroachModel = this.placeholder;
          // Always create physics body for placeholder
          this.createPhysicsBody();
        }
      }
      
      createPlaceholderCockroach() {
        // Create a simple placeholder using basic shapes
        const group = new THREE.Group();
        
        // Body - using CylinderGeometry instead of CapsuleGeometry for compatibility
        const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.5, 8);
        const bodyMaterial = new THREE.MeshStandardMaterial({
          color: 0x663300,
          roughness: 0.8
        });
        
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.rotation.z = Math.PI / 2;
        body.position.y = 0.2; // Lift slightly above ground
        group.add(body);
        
        // Add legs
        for (let i = 0; i < 3; i++) {
          const legGeometry = new THREE.CylinderGeometry(0.02, 0.01, 0.3);
          const legMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
          
          // Left leg
          const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
          leftLeg.position.set(0.2, 0.15, 0.2 - (i * 0.2));
          leftLeg.rotation.z = Math.PI / 4;
          group.add(leftLeg);
          
          // Right leg
          const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
          rightLeg.position.set(-0.2, 0.15, 0.2 - (i * 0.2));
          rightLeg.rotation.z = -Math.PI / 4;
          group.add(rightLeg);
        }
        
        // Position the placeholder
        group.position.set(0, 0.5, 0);
        this.placeholder = group;
        // Add to scene
        this.scene.add(this.placeholder);
        
        console.log('Created placeholder cockroach');
      }
      
      createPhysicsBody() {
        if (!this.cockroachModel) {
          console.error("Cannot create physics body: No cockroach model found");
          return;
        }
        
        console.log("Creating physics body for cockroach");
        
        // Get bounding box of model to estimate size
        const boundingBox = new THREE.Box3().setFromObject(this.cockroachModel);
        const size = new THREE.Vector3();
        boundingBox.getSize(size);
        
        // Use a sphere collider initially (can be replaced with more complex shape later)
        const radius = Math.max(size.x, size.y, size.z) / 2 * 0.8; // 80% of half the largest dimension
        console.log(`Creating physics body with radius: ${radius.toFixed(2)}`);
        
        // Create the physics body
        const shape = new CANNON.Sphere(radius > 0.01 ? radius : 0.1);
        
        // Get current position
        const worldPos = new THREE.Vector3();
        this.cockroachModel.getWorldPosition(worldPos);
        const position = new CANNON.Vec3(worldPos.x, worldPos.y, worldPos.z);
        
        // Create the body with appropriate mass
        this.cockroachBody = new CANNON.Body({
          mass: 1, // 1kg
        });
        
        // Add the shape to the body
        this.cockroachBody.addShape(shape);
        
        // Set the position
        this.cockroachBody.position.copy(position);
        
        // Set damping properties (to prevent excessive sliding/spinning)
        this.cockroachBody.linearDamping = 0.9;
        this.cockroachBody.angularDamping = 0.9;
        
        // Add the body to physics world
        if (this.game.physicsWorld) {
          this.game.physicsWorld.addBody(this.cockroachBody);
          console.log('Physics body added to world');
        } else {
          console.error('No physics world found!');
        }
      }
      
      setupInputHandlers() {
        console.log('Setting up input handlers...');
        // Binding methods to 'this' context
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.handleKeyUp = this.handleKeyUp.bind(this);
        this.handleZoom = this.handleZoom.bind(this); // Ensure handleZoom is bound

        // Add event listeners to the game container and document as fallback
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
          // Direct event listeners for keyboard
          gameContainer.addEventListener('keydown', this.handleKeyDown);
          gameContainer.addEventListener('keyup', this.handleKeyUp);
          document.addEventListener('keydown', this.handleKeyDown);
          document.addEventListener('keyup', this.handleKeyUp);

          // REMOVED OLD Mouse wheel zoom listener
          // gameContainer.addEventListener('wheel', this.handleZoom, { passive: false });

          // Button zoom listeners (remain unchanged, pass simulated event)
          const zoomInButton = document.getElementById('zoom-in');
          const zoomOutButton = document.getElementById('zoom-out');
          if (zoomInButton && zoomOutButton) {
              // Simulate wheel event object structure for consistency
              zoomInButton.addEventListener('click', () => this.handleZoom({ deltaY: -100, preventDefault: () => {} }));
              zoomOutButton.addEventListener('click', () => this.handleZoom({ deltaY: 100, preventDefault: () => {} }));
          }
        }

        // Add message listener for zoom events from parent window
        window.addEventListener('message', (event) => {
          console.log('Message received:', event.data);
          if (event.data && event.data.type === 'zoom' && typeof event.data.deltaY === 'number') {
            console.log('Processing zoom event with deltaY:', event.data.deltaY);
            // Simulate a wheel event object for the handleZoom function
            const simulatedEvent = {
              deltaY: event.data.deltaY,
              preventDefault: () => {} // Add a stub function
            };
            this.handleZoom(simulatedEvent);
          }
        });

        // Also listen for direct wheel events inside the iframe as fallback
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
          console.log('Adding wheel event listener to game container');
          gameContainer.addEventListener('wheel', (event) => {
            console.log('Wheel event detected with deltaY:', event.deltaY);
            this.handleZoom(event);
          }, { passive: false });
        }

        console.log('Input handlers and zoom listeners set up successfully');
      }
      
      setupDebugControls() {
        // Create debug camera controls
      if (typeof THREE.OrbitControls !== 'undefined') {
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
      } else {
        console.warn('THREE.OrbitControls is not available. Debug camera controls will not work.');
        return;
      }
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        console.log('Debug controls enabled (press T to toggle)');
      }
      
      disableDebugControls() {
        if (this.controls) {
          this.controls.dispose();
          this.controls = null;
          console.log('Debug controls disabled');
        }
      }
    
      update(delta) {
        // Process keyboard input
        this.handleInput(delta); // Process movement based on keys

        // Update animations
        this.updateMovement(delta); // Update walk/idle animations
        if (this.mixer) {
          this.mixer.update(delta);
        }

        // Update camera position and zoom
        this.updateCamera();
      }
      
      // Update visual key indicators
      updateKeyIndicators() {
        const keyIndicator = document.getElementById('key-indicator');
        if (!keyIndicator) return;
        
        // Show indicator if any key is pressed
        const anyKeyPressed = this.keys.forward || this.keys.backward || this.keys.left || this.keys.right || this.keys.jump;
        keyIndicator.style.display = anyKeyPressed ? 'grid' : 'none';
        
        // Update individual keys
        const keyUp = document.getElementById('key-up');
        const keyDown = document.getElementById('key-down');
        const keyLeft = document.getElementById('key-left');
        const keyRight = document.getElementById('key-right');
        
        if (keyUp) keyUp.style.backgroundColor = this.keys.forward ? 'rgba(0,255,102,0.8)' : 'rgba(0,255,102,0.2)';
        if (keyDown) keyDown.style.backgroundColor = this.keys.backward ? 'rgba(0,255,102,0.8)' : 'rgba(0,255,102,0.2)';
        if (keyLeft) keyLeft.style.backgroundColor = this.keys.left ? 'rgba(0,255,102,0.8)' : 'rgba(0,255,102,0.2)';
        if (keyRight) keyRight.style.backgroundColor = this.keys.right ? 'rgba(0,255,102,0.8)' : 'rgba(0,255,102,0.2)';
      }
      
      // Update animations based on movement state
      updateMovement(delta) {
        // Skip physics-based updates - we're using direct position control now
        // Handle animations based on movement state
        if (this.mixer && this.animations) {
          // Determine if the cockroach is moving based on key presses
          const isMoving = this.keys.forward || this.keys.backward || this.keys.left || this.keys.right;
          
          // Play appropriate animation
          if (isMoving && this.animations.walk && !this.animations.walk.isRunning()) {
            console.log('Playing WALK animation');
            // Transition to walk animation
            Object.values(this.animations).forEach(anim => {
              if (anim && anim.isRunning()) {
                anim.fadeOut(0.2); // Smooth transition out
              }
            });
            this.animations.walk.reset().fadeIn(0.2).play();
          } else if (!isMoving && this.animations.idle && !this.animations.idle.isRunning()) {
            console.log('Playing IDLE animation');
            // Transition to idle animation
            Object.values(this.animations).forEach(anim => {
              if (anim && anim.isRunning()) {
                anim.fadeOut(0.2); // Smooth transition out
              }
            });
            this.animations.idle.reset().fadeIn(0.2).play();
          }
        }
        
        // Log cockroach position occasionally
        if (this.cockroachModel && Math.random() < 0.05) {
          console.log('Cockroach direct position:', this.cockroachModel.position);
        }
      }
      
      updateCamera() {
        console.log("updateCamera running"); // DEBUG LOG
        if (this.debugMode) return; // Skip if in debug mode with orbit controls

        // Get target (either cockroach model or placeholder)
        const target = this.cockroachModel ? this.cockroachModel.position.clone() :
                      (this.placeholder ? this.placeholder.position.clone() : new THREE.Vector3(0, 0.5, 0));

        // Calculate new camera position based on target position
        // Use zoomLevel for Z offset, fixed Y offset
        // REMOVED: const adjustedYOffset = this.cameraOffset.y + (this.zoomLevel - 5) * 0.2; // Slightly raise/lower camera with zoom
        const offset = new THREE.Vector3(0, this.cameraOffset.y, this.zoomLevel); // Use fixed Y, dynamic zoom for Z

        // Apply rotation if model exists
        if (this.cockroachModel) {
          offset.applyQuaternion(this.cockroachModel.quaternion);
        }

        const cameraPosition = target.clone().add(offset);
        this.camera.position.lerp(cameraPosition, 0.05); // SMOOTHER camera movement (was 0.1)

        // Look at target slightly above ground level
        this.camera.lookAt(target.add(new THREE.Vector3(0, 0.5, 0)));
      }
      
      // Handle zoom input (mouse wheel or buttons)
      handleZoom(event) {
        event.preventDefault();
        const zoomDelta = event.deltaY;
        const newZoomLevel = this.zoomLevel - zoomDelta * this.zoomSpeed;
        this.zoomLevel = Math.min(Math.max(newZoomLevel, this.minZoom), this.maxZoom);
        console.log('Zoom level:', this.zoomLevel);
      }
      
      update(delta) {
        // Process keyboard input
        this.handleInput(delta);
        
        // Update animations
        this.updateMovement(delta);
        if (this.mixer) {
          this.mixer.update(delta);
        }
        
        // Update camera position and zoom
        this.updateCamera();
        
        // Debug mode controls update
        if (this.debugMode && this.controls) {
          this.controls.update();
        }
      }
      
      updateCamera() {
        // Skip if in debug mode with orbit controls
        if (this.debugMode) return;
        
        // Get target (either cockroach model or placeholder)
        const target = this.cockroachModel ? this.cockroachModel.position.clone() : 
                      (this.placeholder ? this.placeholder.position.clone() : new THREE.Vector3(0, 0.5, 0));
        
        // Calculate new camera position based on target position
        // Use fixed Y offset and dynamic Z based on zoom level
        const offset = new THREE.Vector3(0, this.cameraOffset.y, this.zoomLevel);
        
        // Apply rotation if model exists
        if (this.cockroachModel) {
          offset.applyQuaternion(this.cockroachModel.quaternion);
        }
        
        const cameraPosition = target.clone().add(offset);
        this.camera.position.lerp(cameraPosition, 0.05); // Smooth camera movement
        
        // Look at target slightly above ground level
        const lookTarget = target.clone();
        lookTarget.y += 0.5; // Look at a point slightly above the cockroach
        this.camera.lookAt(lookTarget);
        
        // Debug logging
        if (Math.random() < 0.01) {
          console.log('Camera position:', this.camera.position, 'Looking at:', lookTarget, 'Zoom:', this.zoomLevel);
        }
      }
      
      // Handle zoom input (mouse wheel or buttons)
      handleZoom(event) {
        console.log("handleZoom called with deltaY:", event.deltaY);
        
        // Prevent scrolling if preventDefault exists on the event
        if (event.preventDefault) {
          event.preventDefault();
        }
        
        // Calculate zoom delta based on wheel direction
        // Negative deltaY means scroll up (zoom in)
        // Positive deltaY means scroll down (zoom out)
        const zoomDelta = event.deltaY * 0.01; // Reduce sensitivity for smoother zoom
        
        // Update zoom level
        this.zoomLevel += zoomDelta * this.zoomSpeed;
        
        // Clamp zoom level
        this.zoomLevel = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoomLevel));
        
        console.log('Zoom level changed to:', this.zoomLevel);
      }
      
      // Add helper objects for debugging
      addHelpers() {
        // Add axis helper
        const axisHelper = new THREE.AxesHelper(5);
        this.scene.add(axisHelper);
        
        // Add grid helper
        const gridHelper = new THREE.GridHelper(20, 20);
        this.scene.add(gridHelper);
        
        console.log('Debug helpers added to scene');
      }
      
      dispose() {
        // Clean up resources and event listeners
        window.removeEventListener('keydown', this.handleKeyDown);
        window.removeEventListener('keyup', this.handleKeyUp);
        
        this.disableDebugControls();
        
        this.objects.forEach(obj => {
          this.scene.remove(obj);
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) obj.material.dispose();
        });
        
        // Clean up any animations/mixers
        if (this.mixer) {
          this.mixer.stopAllAction();
        }
        
        console.log('Free World mode disposed');
      }
    }
    
    // Initialize the game
    const game = new Game();
    
    // Start with American cockroach by default
    // Force focus on game container when page loads
    window.addEventListener('load', () => {
      const gameContainer = document.getElementById('game-container');
      if (gameContainer) {
        // Create a focus message for players
        createFocusMessage();
        
        // Show focus overlay
        const focusOverlay = document.getElementById('focus-overlay');
        if (focusOverlay) {
          focusOverlay.style.display = 'flex';
        }
        
        // Set a timeout to attempt focus
        setTimeout(() => {
          gameContainer.focus();
          console.log('Game container focused on page load');
        }, 200);
      }
    });
    
    // Create a focus message for players
    function createFocusMessage() {
      // Show a message about focusing with black and orange styling
      const focusMessage = document.createElement('div');
      focusMessage.style.position = 'absolute';
      focusMessage.style.bottom = '10px';
      focusMessage.style.right = '10px';
      focusMessage.style.backgroundColor = '#000000';
      focusMessage.style.color = '#FF8000';
      focusMessage.style.padding = '10px';
      focusMessage.style.borderRadius = '0';
      focusMessage.style.fontFamily = 'Arial, sans-serif';
      focusMessage.style.zIndex = '1000';
      focusMessage.style.border = '2px solid #FF8000';
      focusMessage.style.fontWeight = 'bold';
      focusMessage.textContent = 'Click in the game area to enable controls';
      focusMessage.style.transition = 'opacity 0.5s';
      document.getElementById('game-container').appendChild(focusMessage);
      
      // Make it disappear after clicking or 5 seconds
      focusMessage.addEventListener('click', () => {
        if (focusMessage.parentNode) {
          focusMessage.parentNode.removeChild(focusMessage);
        }
      });
      while(game.scene.children.length > 0){ 
        game.scene.remove(game.scene.children[0]); 
      }
      game.setupBasicLighting();
      
      // Start with Oriental cockroach
      game.startGame('free-world', 'oriental');
    };
  </script>
</body>
</html>
