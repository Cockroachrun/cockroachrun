<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cockroach Run - Free World Test</title>
  <!-- Load Three.js libraries from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <!-- Load Cannon.js physics engine (using original Cannon for direct script tag compatibility) -->
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #121212;
      color: #00FF66;
      font-family: 'Orbitron', sans-serif;
    }
    
    #game-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      box-sizing: border-box;
      border: 3px dashed #9333EA;
      z-index: 10;
    }
    #game-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #121212;
    }
    
    #instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: #00FF66;
      padding: 10px;
      border: 1px solid #00FF66;
      border-radius: 5px;
      z-index: 1000;
      pointer-events: none;
      user-select: none;
      max-width: 300px;
    }
    
    #character-selector {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: #00FF66;
      padding: 10px;
      border: 1px solid #00FF66;
      border-radius: 5px;
      z-index: 1000;
    }
    
    button {
      background-color: #9333EA;
      color: white;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 3px;
      font-family: 'Exo 2', sans-serif;
      margin: 5px;
    }
    
    button:hover {
      background-color: #7B2AC5;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas"></canvas>
  </div>
  
  <div id="instructions">
    <h3>Controls:</h3>
    <p>W/Up Arrow - Move Forward</p>
    <p>S/Down Arrow - Move Backward</p>
    <p>A/Left Arrow - Rotate Left</p>
    <p>D/Right Arrow - Rotate Right</p>
    <p>T - Toggle Debug Camera Mode</p>
  </div>
  
  <div id="character-selector">
    <button id="american-roach">American Cockroach</button>
    <button id="oriental-roach">Oriental Cockroach</button>
  </div>

  <script>
    // Basic game engine
    class Game {
      constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.canvas = null;
        this.clock = new THREE.Clock();
        this.activeMode = null;
        this.selectedCharacter = 'american'; // Default
        this.physicsWorld = null; // Physics world
        this.physicsBodies = []; // Track physics bodies
        
        // Initialize
        this.canvas = document.getElementById('game-canvas');
        this.renderer = new THREE.WebGLRenderer({
          canvas: this.canvas,
          antialias: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x121212);
        
        this.camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        
        // Initialize physics world
        this.initPhysicsWorld();
        
        // Handle window resize
        this.setupResizeHandler();
        
        // Add basic lighting
        this.setupBasicLighting();
      }
      
      initPhysicsWorld() {
        // Create physics world with Earth gravity
        this.physicsWorld = new CANNON.World();
        this.physicsWorld.gravity.set(0, -9.82, 0);
        
        // Configure solver iterations for stability
        this.physicsWorld.solver.iterations = 10;
        
        // Set default material properties
        const defaultMaterial = new CANNON.Material('default');
        const defaultContactMaterial = new CANNON.ContactMaterial(
          defaultMaterial,
          defaultMaterial,
          {
            friction: 0.3,
            restitution: 0.2
          }
        );
        this.physicsWorld.addContactMaterial(defaultContactMaterial);
        
        // Create a ground plane
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({
          mass: 0 // Static body
        });
        groundBody.addShape(groundShape);
        groundBody.material = defaultMaterial;
        
        // Rotate ground to be horizontal (X rotation by -90 degrees)
        const quaternion = new CANNON.Quaternion();
        quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        groundBody.quaternion.copy(quaternion);
        
        // Add ground to world
        this.physicsWorld.addBody(groundBody);
        this.physicsBodies.push(groundBody);
        
        console.log('Physics world initialized');
      }
      
      setupResizeHandler() {
        window.addEventListener('resize', () => {
          const width = this.container.offsetWidth;
          const height = this.container.offsetHeight;
          this.renderer.setSize(width, height, false);
          this.camera.aspect = width / height;
          this.camera.updateProjectionMatrix();
        });
      }
      
      setupBasicLighting() {
        // Ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); // Brighter ambient
        this.scene.add(ambientLight);
        
        // Directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2); // Stronger directional
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        
        // Configure shadow properties
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        
        this.scene.add(directionalLight);
      }
      
      startGame(mode, character) {
        this.selectedCharacter = character;
        this.isRunning = true;
        
        // Initialize Free World mode
        if (mode === 'free-world') {
          this.activeGameMode = new FreeWorldMode(this);
          this.activeGameMode.init();
          
          // Start game loop
          this.gameLoop();
        }
      }
      
      gameLoop() {
        // Get delta time
        const delta = this.clock.getDelta();
        
        // Clamp delta to avoid large physics jumps
        const fixedDelta = Math.min(delta, 0.1);
        
        // Step the physics world simulation
        if (this.physicsWorld) {
          this.physicsWorld.step(1/60, fixedDelta, 3);
        }
        
        // Update game state if running
        if (this.isRunning && this.activeGameMode) {
          this.activeGameMode.update(delta);
        }
        
        // Render the scene
        this.renderer.render(this.scene, this.camera);
        
        // Call next frame
        requestAnimationFrame(this.gameLoop.bind(this));
      }
    }
    
    // Free World Mode
    class FreeWorldMode {
      constructor(game) {
        this.game = game;
        this.objects = [];
        this.clock = new THREE.Clock();
        this.cockroachModel = null; // Visual model
        this.cockroachBody = null;  // Physics body - NEW!
        this.isModelLoaded = false;
        this.mixer = null;
        this.animations = {};
        
        // Movement properties
        this.moveSpeed = 2;
        this.rotationSpeed = 2;
        
        // Input state
        this.keys = {
          forward: false,
          backward: false,
          left: false,
          right: false,
          jump: false
        };
        
        // Camera following
        this.cameraOffset = new THREE.Vector3(0, 3, 5);  // Higher and further back
        this.cameraTarget = new THREE.Vector3(0, 0.5, 0);  // Looking at a point slightly above ground
        
        // Debugging
        this.debugMode = true;
      }
    
      init() {
        console.log('Initializing Free World mode');
        
        // Basic scene setup
        this.setupScene();
        
        // Create a simple environment
        this.createEnvironment();
        
        // Add helpers for debugging
        this.addHelpers();
        
        // Setup input handlers
        this.setupInputHandlers();
        
        // Load and create character based on the selected character
        this.createCharacter();
        
        // Create camera controls for debugging
        if (this.debugMode) {
          this.setupDebugControls();
        }
        
        return this;
      }
      
      setupScene() {
        // Get reference to Three.js components
        this.scene = this.game.scene;
        this.camera = this.game.camera;
        this.renderer = this.game.renderer;
        
        // Set a cyberpunk background color
        this.scene.background = new THREE.Color(0x121212);
        
        // Position camera initially
        this.camera.position.set(0, 3, 8); // Standardized for all modes (adjust as per UI baseline)
        this.camera.lookAt(0, 0, 0);
        
        // Add cyberpunk accent lights
        this.addLights();
      }
      
      addLights() {
        // Add cyberpunk-style accent lights
        const purpleLight = new THREE.PointLight(0x9333EA, 1, 10);
        purpleLight.position.set(-5, 1, 0);
        this.scene.add(purpleLight);
        
        const greenLight = new THREE.PointLight(0x00FF66, 1, 10);
        greenLight.position.set(5, 1, 0);
        this.scene.add(greenLight);
      }
    
      createEnvironment() {
        // Create a simple ground plane
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshStandardMaterial({
          color: 0x333333, // Standard ground color per PRD
          roughness: 0.8,
          metalness: 0.2
        });
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
        ground.receiveShadow = true;
        this.scene.add(ground);
        
        // Add a few simple obstacles to test collision/movement
        this.addObstacle(-5, 0.5, -5, 1, 1, 1, 0x9333EA); // Purple box
        this.addObstacle(5, 0.5, -3, 1, 1, 1, 0x00FF66);  // Green box
      }
      
      addObstacle(x, y, z, width, height, depth, color) {
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshStandardMaterial({
          color: color,
          roughness: 0.7,
          metalness: 0.3
        });
        
        const obstacle = new THREE.Mesh(geometry, material);
        obstacle.position.set(x, y, z);
        obstacle.castShadow = true;
        obstacle.receiveShadow = true;
        
        this.scene.add(obstacle);
        this.objects.push(obstacle);
        
        return obstacle;
      }
    
      createCharacter() {
        const selectedCharacter = this.game.selectedCharacter || 'american';
        
        // Determine which model to load based on selection
        const modelPath = selectedCharacter === 'american' ? 
          'assets/models/American Cockroach.glb' : 
          'assets/models/Oriental cockroach.glb';
        
        console.log(`Loading cockroach model: ${modelPath}`);
        
        // Create a placeholder while the model loads
        this.createPlaceholderCockroach();
// Ensure placeholder is used as cockroachModel so physics and controls work
this.cockroachModel = this.placeholder;
// Always create physics body for placeholder
this.createPhysicsBody();
        
        // Load the actual model if GLTFLoader is available
        if (typeof THREE.GLTFLoader !== 'undefined') {
          console.log('GLTFLoader is available, loading model...');
          const loader = new THREE.GLTFLoader();
          
          // Add loading progress tracking
          loader.load(
            modelPath,
            (gltf) => {
              console.log('Model loaded successfully:', gltf);
              
              // Remove placeholder when the real model is loaded
              if (this.placeholder) {
                this.scene.remove(this.placeholder);
                this.placeholder = null;
              }
              
              // Process the loaded model
              this.cockroachModel = gltf.scene;
              this.cockroachModel.traverse(node => {
                if (node.isMesh) {
                  node.castShadow = true;
                  node.receiveShadow = true;
                }
              });
              
              // Scale and position the model appropriately
              this.cockroachModel.scale.set(0.1, 0.1, 0.1);
              this.cockroachModel.position.set(0, 0.1, 0); // Slight elevation to avoid ground clipping
              
              // Log position for debugging
              console.log('Cockroach model positioned at:', this.cockroachModel.position);
              
              // Add to scene
              this.scene.add(this.cockroachModel);
              
              // Create physics body for the cockroach
              this.createPhysicsBody();
              
              // Setup animations if any
              if (gltf.animations && gltf.animations.length > 0) {
                this.mixer = new THREE.AnimationMixer(this.cockroachModel);
                
                gltf.animations.forEach(clip => {
                  const name = clip.name.toLowerCase();
                  this.animations[name] = this.mixer.clipAction(clip);
                  
                  // Play idle animation by default
                  if (name.includes('idle')) {
                    this.animations[name].play();
                  }
                });
              }
              
              this.isModelLoaded = true;
            },
            (xhr) => {
              console.log(`Loading model: ${(xhr.loaded / (xhr.total || 1)) * 100}% loaded`);
            },
            (error) => {
              console.error('Error loading model:', error);
            }
          );
        } else {
          console.warn('THREE.GLTFLoader is not available. Using placeholder cockroach only.');
          // Always create placeholder cockroach if model is not available
          this.createPlaceholderCockroach();
          // IMPORTANT: Set cockroachModel to placeholder, so the rest of the code works the same way
          this.cockroachModel = this.placeholder;
          // Always create physics body for placeholder
          this.createPhysicsBody();
        }
      }
      
      createPlaceholderCockroach() {
        // Create a simple placeholder using basic shapes
        const group = new THREE.Group();
        
        // Body - using CylinderGeometry instead of CapsuleGeometry for compatibility
        const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.5, 8);
        const bodyMaterial = new THREE.MeshStandardMaterial({
          color: 0x663300,
          roughness: 0.8
        });
        
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.rotation.z = Math.PI / 2;
        body.position.y = 0.2; // Lift slightly above ground
        group.add(body);
        
        // Add legs
        for (let i = 0; i < 3; i++) {
          const legGeometry = new THREE.CylinderGeometry(0.02, 0.01, 0.3);
          const legMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
          
          // Left leg
          const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
          leftLeg.position.set(0.2, 0.15, 0.2 - (i * 0.2));
          leftLeg.rotation.z = Math.PI / 4;
          group.add(leftLeg);
          
          // Right leg
          const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
          rightLeg.position.set(-0.2, 0.15, 0.2 - (i * 0.2));
          rightLeg.rotation.z = -Math.PI / 4;
          group.add(rightLeg);
        }
        
        // Position the placeholder
        group.position.set(0, 0.5, 0);
        this.placeholder = group;
        // Add to scene
        this.scene.add(this.placeholder);
        
        console.log('Created placeholder cockroach');
      }
      
      createPhysicsBody() {
        if (!this.cockroachModel) {
          console.error("Cannot create physics body: No cockroach model found");
          return;
        }
        
        console.log("Creating physics body for cockroach");
        
        // Get bounding box of model to estimate size
        const boundingBox = new THREE.Box3().setFromObject(this.cockroachModel);
        const size = new THREE.Vector3();
        boundingBox.getSize(size);
        
        // Use a sphere collider initially (can be replaced with more complex shape later)
        const radius = Math.max(size.x, size.y, size.z) / 2 * 0.8; // 80% of half the largest dimension
        console.log(`Creating physics body with radius: ${radius.toFixed(2)}`);
        
        // Create the physics body
        const shape = new CANNON.Sphere(radius > 0.01 ? radius : 0.1);
        
        // Get current position
        const worldPos = new THREE.Vector3();
        this.cockroachModel.getWorldPosition(worldPos);
        const position = new CANNON.Vec3(worldPos.x, worldPos.y, worldPos.z);
        
        // Create the body with appropriate mass
        this.cockroachBody = new CANNON.Body({
          mass: 1, // 1kg
        });
        
        // Add the shape to the body
        this.cockroachBody.addShape(shape);
        
        // Set the position
        this.cockroachBody.position.copy(position);
        
        // Set damping properties (to prevent excessive sliding/spinning)
        this.cockroachBody.linearDamping = 0.9;
        this.cockroachBody.angularDamping = 0.9;
        
        // Add the body to physics world
        if (this.game.physicsWorld) {
          this.game.physicsWorld.addBody(this.cockroachBody);
          console.log('Physics body added to world');
        } else {
          console.error('No physics world found!');
        }
      }
      
      setupInputHandlers() {
        // Keyboard event listeners
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.handleKeyUp = this.handleKeyUp.bind(this);
        
        window.addEventListener('keydown', this.handleKeyDown);
        window.addEventListener('keyup', this.handleKeyUp);
      }
      
      handleKeyDown(event) {
        switch(event.code) {
          case 'KeyW':
          case 'ArrowUp':
            this.keys.forward = true;
            break;
          case 'KeyS':
          case 'ArrowDown':
            this.keys.backward = true;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            this.keys.left = true;
            break;
          case 'KeyD':
          case 'ArrowRight':
            this.keys.right = true;
            break;
          case 'Space':
            this.keys.jump = true;
            break;
          case 'KeyT': // Toggle debug mode
            if (this.debugMode) {
              this.disableDebugControls();
              this.debugMode = false;
            } else {
              this.setupDebugControls();
              this.debugMode = true;
            }
            break;
        }
      }
      
      handleKeyUp(event) {
        switch(event.code) {
          case 'KeyW':
          case 'ArrowUp':
            this.keys.forward = false;
            break;
          case 'KeyS':
          case 'ArrowDown':
            this.keys.backward = false;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            this.keys.left = false;
            break;
          case 'KeyD':
          case 'ArrowRight':
            this.keys.right = false;
            break;
          case 'Space':
            this.keys.jump = false;
            break;
        }
      }
      
      setupDebugControls() {
        // Create debug camera controls
      if (typeof THREE.OrbitControls !== 'undefined') {
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
      } else {
        console.warn('THREE.OrbitControls is not available. Debug camera controls will not work.');
        return;
      }
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        console.log('Debug controls enabled (press T to toggle)');
      }
      
      disableDebugControls() {
        if (this.controls) {
          this.controls.dispose();
          this.controls = null;
          console.log('Debug controls disabled');
        }
      }
    
      update(delta) {
        // Handle keyboard input
        this.handleInput();
        
        // Update player movement
        this.updateMovement(delta);
        
        // Update camera position
        this.updateCamera();
        
        // Update animations
        if (this.mixer) {
          this.mixer.update(delta);
        }
        
        // Update orbit controls if in debug mode
        if (this.debugMode && this.controls) {
          this.controls.update();
        }
        
        // Log position of cockroach every few seconds (for debugging)
        if (this.cockroachModel && Math.random() < 0.01) {
          console.log('Cockroach position:', this.cockroachModel.position);
        }
      }
      
      updateCamera() {
        if (this.debugMode) return; // Skip if in debug mode with orbit controls
        
        // Get target (either cockroach model or placeholder)
        const target = this.cockroachModel ? this.cockroachModel.position.clone() : 
                      (this.placeholder ? this.placeholder.position.clone() : new THREE.Vector3(0, 0.5, 0));
        
        // Calculate new camera position based on target position
        const offset = new THREE.Vector3(0, 3, 5); // Camera offset behind and above the cockroach
        
        // Apply rotation if model exists
        if (this.cockroachModel) {
          offset.applyQuaternion(this.cockroachModel.quaternion);
        }
        
        const cameraPosition = target.clone().add(offset);
        this.camera.position.lerp(cameraPosition, 0.1); // Smooth camera movement
        
        // Look at target slightly above ground level
        const lookTarget = target.clone();
        lookTarget.y += 0.5; // Look at a point slightly above the cockroach
        this.camera.lookAt(lookTarget);
        
        // Log camera updates occasionally for debugging
        if (Math.random() < 0.01) {
          console.log('Camera position:', this.camera.position, 'Looking at:', lookTarget);
        }
      }
      
      // Handle keyboard input
      handleInput() {
        // Only apply forces if we have a physics body
        if (!this.cockroachBody) return;

        // Force/torque magnitudes
        const moveForce = 2; // Force magnitude for movement
        const rotateTorque = 0.5; // Torque magnitude for rotation
        
        // Calculate movement force (in local cockroach coordinates)
        let forceZ = 0;
        if (this.keys.forward && !this.keys.backward) {
          forceZ = -moveForce; // Forward is negative Z in model space
        } else if (this.keys.backward && !this.keys.forward) {
          forceZ = moveForce; // Backward is positive Z
        }
        
        if (forceZ !== 0) {
          // Create a local force vector
          const localForce = new CANNON.Vec3(0, 0, forceZ);
          
          // Convert to world space manually (different approach for standard Cannon.js)
          // Create a world force vector
          const worldForce = new CANNON.Vec3();
          // Apply body's rotation to the local force vector
          this.cockroachBody.quaternion.vmult(localForce, worldForce);
          
          // Apply force to physics body
          this.cockroachBody.applyForce(worldForce, this.cockroachBody.position);
          console.log('Applied force:', worldForce);
        }
        
        // Calculate rotation torque
        let torqueY = 0;
        if (this.keys.left && !this.keys.right) {
          torqueY = rotateTorque; // Positive Y torque for left rotation
        } else if (this.keys.right && !this.keys.left) {
          torqueY = -rotateTorque; // Negative Y torque for right rotation
        }
        
        if (torqueY !== 0) {
          // Apply torque around Y axis
          const torque = new CANNON.Vec3(0, torqueY, 0);
          this.cockroachBody.applyTorque(torque);
          console.log('Applied torque:', torque);
        }
        
        // Apply jumping force if jump key is pressed
        if (this.keys.jump) {
          const jumpForce = new CANNON.Vec3(0, 5, 0); // Upward force
          const impulse = new CANNON.Vec3();
          jumpForce.copy(impulse); // Copy values to new vector
          
          // Standard Cannon.js uses applyImpulse with relative point
          const relativePoint = new CANNON.Vec3();
          this.cockroachBody.applyImpulse(impulse, relativePoint);
          
          console.log('Applied jump force');
          this.keys.jump = false; // Reset jump key to prevent continuous jumping
        }
      }
      
      // Update movement physics, animations, etc.
      updateMovement(delta) {
        // Sync visual model to physics body
        if (this.cockroachModel && this.cockroachBody) {
          // Copy position from physics body to visual model
          this.cockroachModel.position.set(
            this.cockroachBody.position.x,
            this.cockroachBody.position.y,
            this.cockroachBody.position.z
          );
          
          // Copy rotation (quaternion) from physics body to visual model
          this.cockroachModel.quaternion.set(
            this.cockroachBody.quaternion.x,
            this.cockroachBody.quaternion.y,
            this.cockroachBody.quaternion.z,
            this.cockroachBody.quaternion.w
          );
        }
        
        // Handle animations based on movement state
        if (this.mixer && this.animations) {
          // Determine if the cockroach is moving based on velocity
          let isMoving = false;
          if (this.cockroachBody) {
            const velocityThreshold = 0.1;
            isMoving = this.cockroachBody.velocity.lengthSquared() > velocityThreshold * velocityThreshold;
          }
          
          // Play appropriate animation
          if (isMoving && this.animations.walk && !this.animations.walk.isRunning()) {
            // Transition to walk animation
            Object.values(this.animations).forEach(anim => {
              if (anim && anim.isRunning()) {
                anim.fadeOut(0.2); // Smooth transition out
              }
            });
            this.animations.walk.reset().fadeIn(0.2).play();
          } else if (!isMoving && this.animations.idle && !this.animations.idle.isRunning()) {
            // Transition to idle animation
            Object.values(this.animations).forEach(anim => {
              if (anim && anim.isRunning()) {
                anim.fadeOut(0.2); // Smooth transition out
              }
            });
            this.animations.idle.reset().fadeIn(0.2).play();
          }
        }
      }
      
      // Add helper objects for debugging
      addHelpers() {
        // Add axis helper
        const axisHelper = new THREE.AxesHelper(5);
        this.scene.add(axisHelper);
        
        // Add grid helper
        const gridHelper = new THREE.GridHelper(20, 20);
        this.scene.add(gridHelper);
        
        console.log('Debug helpers added to scene');
      }
      
      dispose() {
        // Clean up resources and event listeners
        window.removeEventListener('keydown', this.handleKeyDown);
        window.removeEventListener('keyup', this.handleKeyUp);
        
        this.disableDebugControls();
        
        this.objects.forEach(obj => {
          this.scene.remove(obj);
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) obj.material.dispose();
        });
        
        // Clean up any animations/mixers
        if (this.mixer) {
          this.mixer.stopAllAction();
        }
        
        console.log('Free World mode disposed');
      }
    }
    
    // Initialize the game
    const game = new Game();
    
    // Start with American cockroach by default
    game.startGame('free-world', 'american');
    
    // Add character selection buttons
    document.getElementById('american-roach').addEventListener('click', () => {
      // Clear scene
      while(game.scene.children.length > 0){ 
        game.scene.remove(game.scene.children[0]); 
      }
      game.setupBasicLighting();
      
      // Start with American cockroach
      game.startGame('free-world', 'american');
    });
    
    document.getElementById('oriental-roach').addEventListener('click', () => {
      // Clear scene
      while(game.scene.children.length > 0){ 
        game.scene.remove(game.scene.children[0]); 
      }
      game.setupBasicLighting();
      
      // Start with Oriental cockroach
      game.startGame('free-world', 'oriental');
    });
  </script>
</body>
</html>
