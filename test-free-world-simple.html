<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cockroach Run - Free World Test</title>
  <!-- Load Three.js libraries from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <!-- Load Cannon.js physics engine (using original Cannon for direct script tag compatibility) -->
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #121212;
      color: #00FF66;
      font-family: 'Orbitron', sans-serif;
    }
    
    /* Key indicator for visual feedback */
    #key-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: grid;
      grid-template-areas:
        ". up ."
        "left down right";
      grid-gap: 5px;
      z-index: 1000;
      pointer-events: none;
    }
    
    #game-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      box-sizing: border-box;
      border: 3px dashed #9333EA;
      z-index: 10;
      outline: none; /* Remove outline when focused */
      cursor: pointer; /* Show pointer cursor */
    }
    
    #focus-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      color: #00FF66;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      cursor: pointer;
      font-size: 24px;
      text-shadow: 0 0 10px #9333EA;
    }
    #game-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #121212;
    }
    
    #instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: #00FF66;
      padding: 10px;
      border: 1px solid #00FF66;
      border-radius: 5px;
      z-index: 1000;
      pointer-events: none;
      user-select: none;
      max-width: 300px;
    }
    
    #character-selector {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: #00FF66;
      padding: 10px;
      border: 1px solid #00FF66;
      border-radius: 5px;
      z-index: 1000;
    }
    
    button {
      background-color: #9333EA;
      color: white;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 3px;
      font-family: 'Exo 2', sans-serif;
      margin: 5px;
    }
    
    button:hover {
      background-color: #7B2AC5;
    }
  </style>
</head>
<body>
  <div id="game-container" tabindex="0">
    <canvas id="game-canvas"></canvas>
    <div id="focus-overlay">
      <h2>CLICK TO START</h2>
      <p>Click anywhere to gain focus and enable keyboard controls</p>
      <div style="margin-top: 20px; border: 2px solid #00FF66; padding: 10px; max-width: 80%; text-align: center;">
        <p style="margin: 5px 0;">Use WASD or ARROW KEYS to move</p>
        <p style="margin: 5px 0;">SPACE to jump</p>
        <p style="margin: 5px 0;">Movement is a bit slow but should definitely work!</p>
      </div>
    </div>
    
    <!-- Visual key indicators -->
    <div id="key-indicator" style="display: none;">
      <div id="key-up" style="grid-area: up; width: 50px; height: 50px; background-color: rgba(0,255,102,0.2); border: 2px solid #00FF66; text-align: center; line-height: 50px;">W</div>
      <div id="key-left" style="grid-area: left; width: 50px; height: 50px; background-color: rgba(0,255,102,0.2); border: 2px solid #00FF66; text-align: center; line-height: 50px;">A</div>
      <div id="key-down" style="grid-area: down; width: 50px; height: 50px; background-color: rgba(0,255,102,0.2); border: 2px solid #00FF66; text-align: center; line-height: 50px;">S</div>
      <div id="key-right" style="grid-area: right; width: 50px; height: 50px; background-color: rgba(0,255,102,0.2); border: 2px solid #00FF66; text-align: center; line-height: 50px;">D</div>
    </div>
  </div>
  
  <div id="instructions">
    <h3>Controls:</h3>
    <p>W/Up Arrow - Move Forward</p>
    <p>S/Down Arrow - Move Backward</p>
    <p>A/Left Arrow - Rotate Left</p>
    <p>D/Right Arrow - Rotate Right</p>
    <p>T - Toggle Debug Camera Mode</p>
    <div id="position-display" style="margin-top: 10px; background: rgba(0,0,0,0.7); padding: 5px; color: #00FF66;">
      Position: waiting for movement...
    </div>
  </div>
  
  <div id="character-selector">
    <button id="american-roach">American Cockroach</button>
    <button id="oriental-roach">Oriental Cockroach</button>
  </div>

  <script>
    // For direct movement (no physics)
    let lastUpdateTime = 0;
    
    // Basic game engine
    class Game {
      constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.canvas = null;
        this.clock = new THREE.Clock();
        this.activeMode = null;
        this.selectedCharacter = 'american'; // Default
        this.physicsWorld = null; // Physics world
        this.physicsBodies = []; // Track physics bodies
        
        // Initialize
        this.canvas = document.getElementById('game-canvas');
        this.renderer = new THREE.WebGLRenderer({
          canvas: this.canvas,
          antialias: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x121212);
        
        this.camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        
        // Initialize physics world
        this.initPhysicsWorld();
        
        // Handle window resize
        this.setupResizeHandler();
        
        // Add basic lighting
        this.setupBasicLighting();
      }
      
      initPhysicsWorld() {
        // Create physics world with Earth gravity
        this.physicsWorld = new CANNON.World();
        this.physicsWorld.gravity.set(0, -9.82, 0);
        
        // Configure solver iterations for stability
        this.physicsWorld.solver.iterations = 10;
        
        // Set default material properties
        const defaultMaterial = new CANNON.Material('default');
        const defaultContactMaterial = new CANNON.ContactMaterial(
          defaultMaterial,
          defaultMaterial,
          {
            friction: 0.3,
            restitution: 0.2
          }
        );
        this.physicsWorld.addContactMaterial(defaultContactMaterial);
        
        // Create a ground plane
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({
          mass: 0 // Static body
        });
        groundBody.addShape(groundShape);
        groundBody.material = defaultMaterial;
        
        // Rotate ground to be horizontal (X rotation by -90 degrees)
        const quaternion = new CANNON.Quaternion();
        quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        groundBody.quaternion.copy(quaternion);
        
        // Add ground to world
        this.physicsWorld.addBody(groundBody);
        this.physicsBodies.push(groundBody);
        
        console.log('Physics world initialized');
      }
      
      setupResizeHandler() {
        window.addEventListener('resize', () => {
          const width = this.container.offsetWidth;
          const height = this.container.offsetHeight;
          this.renderer.setSize(width, height, false);
          this.camera.aspect = width / height;
          this.camera.updateProjectionMatrix();
        });
      }
      
      setupBasicLighting() {
        // Ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); // Brighter ambient
        this.scene.add(ambientLight);
        
        // Directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2); // Stronger directional
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        
        // Configure shadow properties
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        
        this.scene.add(directionalLight);
      }
      
      startGame(mode, character) {
        this.selectedCharacter = character;
        this.isRunning = true;
        
        // Initialize Free World mode
        if (mode === 'free-world') {
          this.activeGameMode = new FreeWorldMode(this);
          this.activeGameMode.init();
          
          // Start game loop
          this.gameLoop();
        }
      }
      
      gameLoop() {
        // Get delta time
        const delta = this.clock.getDelta();
        
        // Clamp delta to avoid large physics jumps
        const fixedDelta = Math.min(delta, 0.1);
        
        // Step the physics world simulation
        if (this.physicsWorld) {
          this.physicsWorld.step(1/60, fixedDelta, 3);
        }
        
        // Update game state if running
        if (this.isRunning && this.activeGameMode) {
          this.activeGameMode.update(delta);
        }
        
        // Render the scene
        this.renderer.render(this.scene, this.camera);
        
        // Call next frame
        requestAnimationFrame(this.gameLoop.bind(this));
      }
    }
    
    // Free World Mode
    class FreeWorldMode {
      constructor(game) {
        this.game = game;
        this.objects = [];
        this.clock = new THREE.Clock();
        this.cockroachModel = null; // Visual model
        this.cockroachBody = null;  // Physics body - NEW!
        this.isModelLoaded = false;
        this.mixer = null;
        this.animations = {};
        
        // Movement properties
        this.moveSpeed = 2;
        this.rotationSpeed = 2;
        
        // Input state
        this.keys = {
          forward: false,
          backward: false,
          left: false,
          right: false,
          jump: false
        };
        
        // Camera following
        this.cameraOffset = new THREE.Vector3(0, 3, 5);  // Higher and further back
        this.cameraTarget = new THREE.Vector3(0, 0.5, 0);  // Looking at a point slightly above ground
        
        // Debugging
        this.debugMode = true;
      }
    
      init() {
        console.log('Initializing Free World mode');
        
        // Create scene, lights, and initial setup
        this.setupScene();
        
        // Create cockroach character
        this.createCharacter();
        
        // Create environment
        this.createEnvironment();
        
        // Setup input handlers
        this.setupInputHandlers();
        
        // For debugging
        this.addHelpers();
        
        // Add direct movement variables
        this.isJumping = false;
        this.jumpTime = 0;
        
        return this;
      }
      
      setupScene() {
        // Get reference to Three.js components
        this.scene = this.game.scene;
        this.camera = this.game.camera;
        this.renderer = this.game.renderer;
        
        // Set a cyberpunk background color
        this.scene.background = new THREE.Color(0x121212);
        
        // Position camera initially
        this.camera.position.set(0, 3, 8); // Standardized for all modes (adjust as per UI baseline)
        this.camera.lookAt(0, 0, 0);
        
        // Add cyberpunk accent lights
        this.addLights();
      }
      
      addLights() {
        // Add cyberpunk-style accent lights
        const purpleLight = new THREE.PointLight(0x9333EA, 1, 10);
        purpleLight.position.set(-5, 1, 0);
        this.scene.add(purpleLight);
        
        const greenLight = new THREE.PointLight(0x00FF66, 1, 10);
        greenLight.position.set(5, 1, 0);
        this.scene.add(greenLight);
      }
    
      createEnvironment() {
        // Create a simple ground plane
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshStandardMaterial({
          color: 0x333333, // Standard ground color per PRD
          roughness: 0.8,
          metalness: 0.2
        });
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
        ground.receiveShadow = true;
        this.scene.add(ground);
        
        // Add a few simple obstacles to test collision/movement
        this.addObstacle(-5, 0.5, -5, 1, 1, 1, 0x9333EA); // Purple box
        this.addObstacle(5, 0.5, -3, 1, 1, 1, 0x00FF66);  // Green box
      }
      
      addObstacle(x, y, z, width, height, depth, color) {
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshStandardMaterial({
          color: color,
          roughness: 0.7,
          metalness: 0.3
        });
        
        const obstacle = new THREE.Mesh(geometry, material);
        obstacle.position.set(x, y, z);
        obstacle.castShadow = true;
        obstacle.receiveShadow = true;
        
        this.scene.add(obstacle);
        this.objects.push(obstacle);
        
        return obstacle;
      }
    
      createCharacter() {
        const selectedCharacter = this.game.selectedCharacter || 'american';
        
        // Try both model paths with fallbacks
        const modelPaths = [
          'assets/models/cockroach.glb',
          'assets/models/American Cockroach.glb',
          'assets/models/Oriental cockroach.glb',
          'assets/models/default-roach.glb',
          // Add variations with different casing
          'assets/models/Cockroach.glb',
          'assets/models/american_cockroach.glb', 
          'assets/models/oriental_cockroach.glb'
        ];
        
        console.log(`Trying to load cockroach model from multiple paths...`);
        
        // Create a placeholder while the model loads
        this.createPlaceholderCockroach();
        // Ensure placeholder is used as cockroachModel so controls work
        this.cockroachModel = this.placeholder;
        
        // Load the actual model if GLTFLoader is available
        if (typeof THREE.GLTFLoader !== 'undefined') {
          console.log('GLTFLoader is available, trying models...');
          const loader = new THREE.GLTFLoader();
          
          // Try loading models in sequence
          this.tryLoadModels(loader, modelPaths, 0);
        } else {
          console.warn('THREE.GLTFLoader is not available. Using placeholder cockroach only.');
        }
      },
      
      // Try loading models sequentially with fallbacks
      tryLoadModels(loader, paths, index) {
        if (index >= paths.length) {
          console.warn('Failed to load any cockroach model. Using placeholder.');
          return;
        }
        
        const modelPath = paths[index];
        console.log(`Trying model path ${index+1}/${paths.length}: ${modelPath}`);
        
        loader.load(
          modelPath,
            (gltf) => {
              console.log('Model loaded successfully:', gltf);
              
              // Remove placeholder when the real model is loaded
              if (this.placeholder) {
                this.scene.remove(this.placeholder);
                this.placeholder = null;
              }
              
              // Model loaded! Remove placeholder
              if (this.placeholder) {
                this.scene.remove(this.placeholder);
              }
              
              console.log('Successfully loaded model from:', modelPath);
              
              // Process the loaded model
              this.cockroachModel = gltf.scene;
              this.cockroachModel.traverse(node => {
                if (node.isMesh) {
                  node.castShadow = true;
                  node.receiveShadow = true;
                }
              });
              
              // Scale and position the model appropriately
              this.cockroachModel.scale.set(0.1, 0.1, 0.1);
              
              // Keep track of the current placeholder position
              if (this.placeholder) {
                // Copy position from placeholder
                this.cockroachModel.position.copy(this.placeholder.position);
                this.cockroachModel.rotation.copy(this.placeholder.rotation);
              } else {
                // Default position
                this.cockroachModel.position.set(0, 0.2, 0);
              }
              
              // Log position for debugging
              console.log('Cockroach model positioned at:', this.cockroachModel.position);
              
              // Add to scene
              this.scene.add(this.cockroachModel);
              
              // Do NOT create physics body - direct control only
              
              // Setup animations if any
              if (gltf.animations && gltf.animations.length > 0) {
                this.mixer = new THREE.AnimationMixer(this.cockroachModel);
                
                gltf.animations.forEach(clip => {
                  const name = clip.name.toLowerCase();
                  this.animations[name] = this.mixer.clipAction(clip);
                  
                  // Play idle animation by default
                  if (name.includes('idle')) {
                    this.animations[name].play();
                  }
                });
              }
              
              this.isModelLoaded = true;
            },
            (xhr) => {
              console.log(`Loading model: ${(xhr.loaded / (xhr.total || 1)) * 100}% loaded`);
            },
            (error) => {
              console.log(`Failed to load model from path: ${modelPath}`, error);
              // Try next model path
              this.tryLoadModels(loader, paths, index + 1);
            }
          );
        } else {
          console.warn('THREE.GLTFLoader is not available. Using placeholder cockroach only.');
          // Always create placeholder cockroach if model is not available
          this.createPlaceholderCockroach();
          // IMPORTANT: Set cockroachModel to placeholder, so the rest of the code works the same way
          this.cockroachModel = this.placeholder;
          // Always create physics body for placeholder
          this.createPhysicsBody();
        }
      }
      
      createPlaceholderCockroach() {
        // Create a simple placeholder using basic shapes
        const group = new THREE.Group();
        
        // Body - using CylinderGeometry instead of CapsuleGeometry for compatibility
        const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.5, 8);
        const bodyMaterial = new THREE.MeshStandardMaterial({
          color: 0x663300,
          roughness: 0.8
        });
        
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.rotation.z = Math.PI / 2;
        body.position.y = 0.2; // Lift slightly above ground
        group.add(body);
        
        // Add legs
        for (let i = 0; i < 3; i++) {
          const legGeometry = new THREE.CylinderGeometry(0.02, 0.01, 0.3);
          const legMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
          
          // Left leg
          const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
          leftLeg.position.set(0.2, 0.15, 0.2 - (i * 0.2));
          leftLeg.rotation.z = Math.PI / 4;
          group.add(leftLeg);
          
          // Right leg
          const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
          rightLeg.position.set(-0.2, 0.15, 0.2 - (i * 0.2));
          rightLeg.rotation.z = -Math.PI / 4;
          group.add(rightLeg);
        }
        
        // Position the placeholder
        group.position.set(0, 0.5, 0);
        this.placeholder = group;
        // Add to scene
        this.scene.add(this.placeholder);
        
        console.log('Created placeholder cockroach');
      }
      
      createPhysicsBody() {
        if (!this.cockroachModel) {
          console.error("Cannot create physics body: No cockroach model found");
          return;
        }
        
        console.log("Creating physics body for cockroach");
        
        // Get bounding box of model to estimate size
        const boundingBox = new THREE.Box3().setFromObject(this.cockroachModel);
        const size = new THREE.Vector3();
        boundingBox.getSize(size);
        
        // Use a sphere collider initially (can be replaced with more complex shape later)
        const radius = Math.max(size.x, size.y, size.z) / 2 * 0.8; // 80% of half the largest dimension
        console.log(`Creating physics body with radius: ${radius.toFixed(2)}`);
        
        // Create the physics body
        const shape = new CANNON.Sphere(radius > 0.01 ? radius : 0.1);
        
        // Get current position
        const worldPos = new THREE.Vector3();
        this.cockroachModel.getWorldPosition(worldPos);
        const position = new CANNON.Vec3(worldPos.x, worldPos.y, worldPos.z);
        
        // Create the body with appropriate mass
        this.cockroachBody = new CANNON.Body({
          mass: 1, // 1kg
        });
        
        // Add the shape to the body
        this.cockroachBody.addShape(shape);
        
        // Set the position
        this.cockroachBody.position.copy(position);
        
        // Set damping properties (to prevent excessive sliding/spinning)
        this.cockroachBody.linearDamping = 0.9;
        this.cockroachBody.angularDamping = 0.9;
        
        // Add the body to physics world
        if (this.game.physicsWorld) {
          this.game.physicsWorld.addBody(this.cockroachBody);
          console.log('Physics body added to world');
        } else {
          console.error('No physics world found!');
        }
      }
      
      setupInputHandlers() {
        // Setup keyboard input with expanded support for different key formats
        this.keys = {
          forward: false,
          backward: false,
          left: false,
          right: false,
          jump: false,
          debug: false
        };
        
        // Simplified key detection - focus only on the critical keys for movement
        this.handleKeyDown = (event) => {
          // Always prevent default browser behavior for navigation keys
          event.preventDefault();
          
          // Log every keydown for debugging
          console.log('Key pressed:', event.key, 'Code:', event.code);
          
          // Simple direct mapping without complex conditions
          switch(event.code) {
            case 'KeyW':
            case 'ArrowUp':
              this.keys.forward = true;
              console.log('FORWARD activated');
              break;
            case 'KeyS':
            case 'ArrowDown':
              this.keys.backward = true;
              console.log('BACKWARD activated');
              break;
            case 'KeyA':
            case 'ArrowLeft':
              this.keys.left = true;
              console.log('LEFT activated');
              break;
            case 'KeyD':
            case 'ArrowRight':
              this.keys.right = true;
              console.log('RIGHT activated');
              break;
            case 'Space':
              this.keys.jump = true;
              console.log('JUMP activated');
              break;
            case 'KeyT':
              this.keys.debug = !this.keys.debug;
              if (this.keys.debug) {
                this.setupDebugControls();
              } else {
                this.disableDebugControls();
              }
              break;
          }
          
          // Update visual key indicators
          this.updateKeyIndicators();
          
          // Log the current input state
          console.log(`Inputs: F=${this.keys.forward}, B=${this.keys.backward}, L=${this.keys.left}, R=${this.keys.right}, J=${this.keys.jump}`);
        };
        
        // Simplified key up handler
        this.handleKeyUp = (event) => {
          // Always prevent default browser behavior for navigation keys
          event.preventDefault();
          
          // Simple direct mapping without complex conditions
          switch(event.code) {
            case 'KeyW':
            case 'ArrowUp':
              this.keys.forward = false;
              break;
            case 'KeyS':
            case 'ArrowDown':
              this.keys.backward = false;
              break;
            case 'KeyA':
            case 'ArrowLeft':
              this.keys.left = false;
              break;
            case 'KeyD':
            case 'ArrowRight':
              this.keys.right = false;
              break;
            case 'Space':
              this.keys.jump = false;
              break;
          }
          
          // Update visual key indicators
          this.updateKeyIndicators();
          
          // Log the current input state after key up
          console.log(`Inputs: F=${this.keys.forward}, B=${this.keys.backward}, L=${this.keys.left}, R=${this.keys.right}, J=${this.keys.jump}`);
        };
        
        // SPECIAL KEY TEST: Add a mechanism to test key events without relying on standard keyboard events
        // This is a backup control method in case of any browser/keyboard issues
        window.activateKeyTest = (key) => {
          // Reset all keys first for clean test
          this.keys.forward = this.keys.backward = this.keys.left = this.keys.right = this.keys.jump = false;
          
          // Set the specific key
          switch(key) {
            case 'up': this.keys.forward = true; break;
            case 'down': this.keys.backward = true; break;
            case 'left': this.keys.left = true; break;
            case 'right': this.keys.right = true; break;
            case 'jump': this.keys.jump = true; break;
          }
          
          console.log(`TEST KEY ACTIVATED: ${key}`);
          console.log(`Inputs: F=${this.keys.forward}, B=${this.keys.backward}, L=${this.keys.left}, R=${this.keys.right}, J=${this.keys.jump}`);
          
          // Update visual indicators
          this.updateKeyIndicators();
          
          // Clear the key after 500ms
          setTimeout(() => {
            this.keys[key === 'up' ? 'forward' : 
                     key === 'down' ? 'backward' : 
                     key === 'jump' ? 'jump' : key] = false;
            this.updateKeyIndicators();
          }, 500);
        };
        
        // Add event listeners to the game container and document as fallback
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
          // Direct event listeners
          gameContainer.addEventListener('keydown', this.handleKeyDown);
          gameContainer.addEventListener('keyup', this.handleKeyUp);
          document.addEventListener('keydown', this.handleKeyDown);
          document.addEventListener('keyup', this.handleKeyUp);
          
          // Handle focus overlay
          const focusOverlay = document.getElementById('focus-overlay');
          if (focusOverlay) {
            focusOverlay.addEventListener('click', () => {
              focusOverlay.style.display = 'none';
              // Show key indicator for visual feedback
              const keyIndicator = document.getElementById('key-indicator');
              if (keyIndicator) keyIndicator.style.display = 'grid';
              
              // Focus the game container
              gameContainer.focus();
              console.log('Game container focused via overlay click');
              
              // Add test buttons to overlay for direct control testing
              const testControls = document.createElement('div');
              testControls.innerHTML = `
                <div style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 2000;">
                  <button onclick="window.activateKeyTest('up')" style="background: #00FF66; color: black; padding: 10px 15px; margin: 5px; border: none;">⬆️ UP</button>
                  <button onclick="window.activateKeyTest('down')" style="background: #00FF66; color: black; padding: 10px 15px; margin: 5px; border: none;">⬇️ DOWN</button>
                  <button onclick="window.activateKeyTest('left')" style="background: #00FF66; color: black; padding: 10px 15px; margin: 5px; border: none;">⬅️ LEFT</button>
                  <button onclick="window.activateKeyTest('right')" style="background: #00FF66; color: black; padding: 10px 15px; margin: 5px; border: none;">➡️ RIGHT</button>
                  <button onclick="window.activateKeyTest('jump')" style="background: #00FF66; color: black; padding: 10px 15px; margin: 5px; border: none;">↑ JUMP</button>
                </div>
              `;
              document.body.appendChild(testControls);
            });
          }
          
          // Add click handler to ensure focus
          gameContainer.addEventListener('click', () => {
            // Hide focus overlay if it exists
            if (focusOverlay) {
              focusOverlay.style.display = 'none';
            }
            
            gameContainer.focus();
            console.log('Game area clicked, ensuring focus');
          });
          
          // Focus the game container on load
          setTimeout(() => {
            gameContainer.focus();
            console.log('Auto-focused game container after timeout');
          }, 500);
        }
        
        console.log('Enhanced input handlers set up with focus management and visual feedback');
      }
      
      setupDebugControls() {
        // Create debug camera controls
      if (typeof THREE.OrbitControls !== 'undefined') {
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
      } else {
        console.warn('THREE.OrbitControls is not available. Debug camera controls will not work.');
        return;
      }
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        console.log('Debug controls enabled (press T to toggle)');
      }
      
      disableDebugControls() {
        if (this.controls) {
          this.controls.dispose();
          this.controls = null;
          console.log('Debug controls disabled');
        }
      }
    
      update(delta) {
        // Handle keyboard input
        this.handleInput();
        
        // Update player movement
        this.updateMovement(delta);
        
        // Update camera position
        this.updateCamera();
        
        // Update animations
        if (this.mixer) {
          this.mixer.update(delta);
        }
        
        // Update orbit controls if in debug mode
        if (this.debugMode && this.controls) {
          this.controls.update();
        }
        
        // Log position of cockroach every few seconds (for debugging)
        if (this.cockroachModel && Math.random() < 0.01) {
          console.log('Cockroach position:', this.cockroachModel.position);
        }
      }
      
      updateCamera() {
        if (this.debugMode) return; // Skip if in debug mode with orbit controls
        
        // Get target (either cockroach model or placeholder)
        const target = this.cockroachModel ? this.cockroachModel.position.clone() : 
                      (this.placeholder ? this.placeholder.position.clone() : new THREE.Vector3(0, 0.5, 0));
        
        // Calculate new camera position based on target position
        const offset = new THREE.Vector3(0, 3, 5); // Camera offset behind and above the cockroach
        
        // Apply rotation if model exists
        if (this.cockroachModel) {
          offset.applyQuaternion(this.cockroachModel.quaternion);
        }
        
        const cameraPosition = target.clone().add(offset);
        this.camera.position.lerp(cameraPosition, 0.1); // Smooth camera movement
        
        // Look at target slightly above ground level
        const lookTarget = target.clone();
        lookTarget.y += 0.5; // Look at a point slightly above the cockroach
        this.camera.lookAt(lookTarget);
        
        // Log camera updates occasionally for debugging
        if (Math.random() < 0.01) {
          console.log('Camera position:', this.camera.position, 'Looking at:', lookTarget);
        }
      }
      
      // Handle keyboard input - USING SUPER DIRECT MOVEMENT 
      handleInput() {
        // Visual key indicator update
        this.updateKeyIndicators();
        
        // Get the target object (either the model or placeholder)
        const target = this.cockroachModel || this.placeholder;
        if (!target) {
          console.error('No target model found for movement!');
          return;
        }

        // INSANELY INCREASED MOVEMENT SPEED for guaranteed visibility
        const moveSpeed = 3.0; // Units per frame - insanely fast for testing
        const rotateSpeed = 0.5; // Radians per frame - very fast rotation

        // Store initial position for comparison
        const initialPosition = target.position.clone();
        let moved = false;
        let targetPosition = target.position.clone();

        // SIMPLE DIRECT MOVEMENT - no direction vectors, just direct coordinate changes
        if (this.keys.forward) {
          console.log('APPLYING FORWARD MOVEMENT');
          targetPosition.z -= moveSpeed; // Forward is negative Z
          moved = true;
        }
        if (this.keys.backward) {
          console.log('APPLYING BACKWARD MOVEMENT');
          targetPosition.z += moveSpeed; // Backward is positive Z
          moved = true;
        }
        if (this.keys.left) {
          console.log('APPLYING LEFT MOVEMENT/ROTATION');
          // Direct X movement for clearer feedback
          targetPosition.x -= moveSpeed;
          target.rotation.y += rotateSpeed;
          moved = true;
        }
        if (this.keys.right) {
          console.log('APPLYING RIGHT MOVEMENT/ROTATION');
          // Direct X movement for clearer feedback
          targetPosition.x += moveSpeed;
          target.rotation.y -= rotateSpeed;
          moved = true;
        }

        // Handle jumping - super high jump
        if (this.keys.jump && !this.isJumping) {
          console.log('JUMP INITIATED');
          this.isJumping = true;
          this.jumpTime = 0;
          this.jumpHeight = target.position.y;
          moved = true;
        }
        if (this.isJumping) {
          this.jumpTime += 0.2; // Faster jump
          targetPosition.y = this.jumpHeight + Math.sin(this.jumpTime) * 5.0; // Much higher jump
          moved = true;
          
          if (this.jumpTime >= Math.PI) {
            this.isJumping = false;
            targetPosition.y = this.jumpHeight;
            this.keys.jump = false;
          }
        }

        // Directly set position - no physics, no smoothing
        if (moved) {
          // FORCE the position change
          target.position.copy(targetPosition);
          
          const posInfo = `COCKROACH MOVED to: x=${target.position.x.toFixed(2)}, y=${target.position.y.toFixed(2)}, z=${target.position.z.toFixed(2)}, rot=${target.rotation.y.toFixed(2)}`;
          console.log(posInfo);
          
          // Update position display in UI with bright highlighting
          const posDisplay = document.getElementById('position-display');
          if (posDisplay) {
            posDisplay.innerHTML = `<strong>Position: x=${target.position.x.toFixed(1)}, y=${target.position.y.toFixed(1)}, z=${target.position.z.toFixed(1)}</strong><br>Rotation: ${(target.rotation.y * 57.3).toFixed(0)}°`;
            posDisplay.style.backgroundColor = 'rgba(255,0,0,0.5)';
            posDisplay.style.color = 'white';
            setTimeout(() => {
              posDisplay.style.backgroundColor = 'rgba(0,0,0,0.7)';
              posDisplay.style.color = '#00FF66';
            }, 300);
          }
          
          // Force matrix update
          target.updateMatrix();
        }
      }
      
      // Update visual key indicators
      updateKeyIndicators() {
        const keyIndicator = document.getElementById('key-indicator');
        if (!keyIndicator) return;
        
        // Show indicator if any key is pressed
        const anyKeyPressed = this.keys.forward || this.keys.backward || this.keys.left || this.keys.right || this.keys.jump;
        keyIndicator.style.display = anyKeyPressed ? 'grid' : 'none';
        
        // Update individual keys
        const keyUp = document.getElementById('key-up');
        const keyDown = document.getElementById('key-down');
        const keyLeft = document.getElementById('key-left');
        const keyRight = document.getElementById('key-right');
        
        if (keyUp) keyUp.style.backgroundColor = this.keys.forward ? 'rgba(0,255,102,0.8)' : 'rgba(0,255,102,0.2)';
        if (keyDown) keyDown.style.backgroundColor = this.keys.backward ? 'rgba(0,255,102,0.8)' : 'rgba(0,255,102,0.2)';
        if (keyLeft) keyLeft.style.backgroundColor = this.keys.left ? 'rgba(0,255,102,0.8)' : 'rgba(0,255,102,0.2)';
        if (keyRight) keyRight.style.backgroundColor = this.keys.right ? 'rgba(0,255,102,0.8)' : 'rgba(0,255,102,0.2)';
      }
      
      // Update animations based on movement state
      updateMovement(delta) {
        // Skip physics-based updates - we're using direct position control now
        // Handle animations based on movement state
        if (this.mixer && this.animations) {
          // Determine if the cockroach is moving based on key presses
          const isMoving = this.keys.forward || this.keys.backward || this.keys.left || this.keys.right;
          
          // Play appropriate animation
          if (isMoving && this.animations.walk && !this.animations.walk.isRunning()) {
            console.log('Playing WALK animation');
            // Transition to walk animation
            Object.values(this.animations).forEach(anim => {
              if (anim && anim.isRunning()) {
                anim.fadeOut(0.2); // Smooth transition out
              }
            });
            this.animations.walk.reset().fadeIn(0.2).play();
          } else if (!isMoving && this.animations.idle && !this.animations.idle.isRunning()) {
            console.log('Playing IDLE animation');
            // Transition to idle animation
            Object.values(this.animations).forEach(anim => {
              if (anim && anim.isRunning()) {
                anim.fadeOut(0.2); // Smooth transition out
              }
            });
            this.animations.idle.reset().fadeIn(0.2).play();
          }
        }
        
        // Log cockroach position occasionally
        if (this.cockroachModel && Math.random() < 0.05) {
          console.log('Cockroach direct position:', this.cockroachModel.position);
        }
      }
      
      // Add helper objects for debugging
      addHelpers() {
        // Add axis helper
        const axisHelper = new THREE.AxesHelper(5);
        this.scene.add(axisHelper);
        
        // Add grid helper
        const gridHelper = new THREE.GridHelper(20, 20);
        this.scene.add(gridHelper);
        
        console.log('Debug helpers added to scene');
      }
      
      dispose() {
        // Clean up resources and event listeners
        window.removeEventListener('keydown', this.handleKeyDown);
        window.removeEventListener('keyup', this.handleKeyUp);
        
        this.disableDebugControls();
        
        this.objects.forEach(obj => {
          this.scene.remove(obj);
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) obj.material.dispose();
        });
        
        // Clean up any animations/mixers
        if (this.mixer) {
          this.mixer.stopAllAction();
        }
        
        console.log('Free World mode disposed');
      }
    }
    
    // Initialize the game
    const game = new Game();
    
    // Start with American cockroach by default
    game.startGame('free-world', 'american');
    
    // Force focus on game container when page loads
    window.addEventListener('load', () => {
      const gameContainer = document.getElementById('game-container');
      if (gameContainer) {
        // Show focus overlay
        const focusOverlay = document.getElementById('focus-overlay');
        if (focusOverlay) {
          focusOverlay.style.display = 'flex';
        }
        
        // Set a timeout to attempt focus
        setTimeout(() => {
          gameContainer.focus();
          console.log('Game container focused on page load');
        }, 200);
      }
    });
    
    // Add character selection buttons
    document.getElementById('american-roach').addEventListener('click', () => {
      // Clear scene
      while(game.scene.children.length > 0){ 
        game.scene.remove(game.scene.children[0]); 
      }
      game.setupBasicLighting();
      
      // Start with American cockroach
      game.startGame('free-world', 'american');
    });
    
    document.getElementById('oriental-roach').addEventListener('click', () => {
      // Clear scene
      while(game.scene.children.length > 0){ 
        game.scene.remove(game.scene.children[0]); 
      }
      game.setupBasicLighting();
      
      // Start with Oriental cockroach
      game.startGame('free-world', 'oriental');
    });
  </script>
</body>
</html>
