<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cockroach Run - Free World Test</title>
  <!-- Load Three.js libraries from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #121212;
      color: #00FF66;
      font-family: 'Orbitron', sans-serif;
    }
    
    #game-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      box-sizing: border-box;
      border: 3px dashed #9333EA;
      z-index: 10;
    }
    #game-canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #121212;
    }
    
    #instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: #00FF66;
      padding: 10px;
      border: 1px solid #00FF66;
      border-radius: 5px;
      z-index: 1000;
      pointer-events: none;
      user-select: none;
      max-width: 300px;
    }
    
    #character-selector {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: #00FF66;
      padding: 10px;
      border: 1px solid #00FF66;
      border-radius: 5px;
      z-index: 1000;
    }
    
    button {
      background-color: #9333EA;
      color: white;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 3px;
      font-family: 'Exo 2', sans-serif;
      margin: 5px;
    }
    
    button:hover {
      background-color: #7B2AC5;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas"></canvas>
  </div>
  
  <div id="instructions">
    <h3>Controls:</h3>
    <p>W/Up Arrow - Move Forward</p>
    <p>S/Down Arrow - Move Backward</p>
    <p>A/Left Arrow - Rotate Left</p>
    <p>D/Right Arrow - Rotate Right</p>
    <p>T - Toggle Debug Camera Mode</p>
  </div>
  
  <div id="character-selector">
    <button id="american-roach">American Cockroach</button>
    <button id="oriental-roach">Oriental Cockroach</button>
  </div>

  <script>
    // Basic game engine
    class Game {
      constructor() {
        // Core properties
        this.container = document.getElementById('game-container');
        this.canvas = document.getElementById('game-canvas');
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, this.container.offsetWidth / this.container.offsetHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
        this.renderer.setSize(this.container.offsetWidth, this.container.offsetHeight, false);
        this.renderer.shadowMap.enabled = true;
        this.clock = new THREE.Clock();
        
        // Game state
        this.isRunning = false;
        this.activeGameMode = null;
        this.selectedCharacter = 'american';
        
        // Setup
        this.setupResizeHandler();
        this.setupBasicLighting();
      }
      
      setupResizeHandler() {
        window.addEventListener('resize', () => {
          const width = this.container.offsetWidth;
          const height = this.container.offsetHeight;
          this.renderer.setSize(width, height, false);
          this.camera.aspect = width / height;
          this.camera.updateProjectionMatrix();
        });
      }
      
      setupBasicLighting() {
        // Ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); // Brighter ambient
        this.scene.add(ambientLight);
        
        // Directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2); // Stronger directional
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        
        // Configure shadow properties
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        
        this.scene.add(directionalLight);
      }
      
      startGame(mode, character) {
        this.selectedCharacter = character;
        this.isRunning = true;
        
        // Initialize Free World mode
        if (mode === 'free-world') {
          this.activeGameMode = new FreeWorldMode(this);
          this.activeGameMode.init();
          
          // Start game loop
          this.gameLoop();
        }
      }
      
      gameLoop() {
        // Get delta time
        const delta = this.clock.getDelta();
        
        // Update game state if running
        if (this.isRunning && this.activeGameMode) {
          this.activeGameMode.update(delta);
        }
        
        // Render the scene
        this.renderer.render(this.scene, this.camera);
        
        // Call next frame
        requestAnimationFrame(this.gameLoop.bind(this));
      }
    }
    
    // Free World Mode
    class FreeWorldMode {
      constructor(game) {
        this.game = game;
        this.objects = [];
        this.clock = new THREE.Clock();
        this.cockroachModel = null;
        this.isModelLoaded = false;
        this.mixer = null;
        this.animations = {};
        
        // Movement properties
        this.moveSpeed = 2;
        this.rotationSpeed = 2;
        
        // Input state
        this.keys = {
          forward: false,
          backward: false,
          left: false,
          right: false,
          jump: false
        };
        
        // Camera following
        this.cameraOffset = new THREE.Vector3(0, 3, 5);  // Higher and further back
        this.cameraTarget = new THREE.Vector3(0, 0.5, 0);  // Looking at a point slightly above ground
        
        // Debugging
        this.debugMode = true;
      }
    
      init() {
        console.log('Initializing Free World mode');
        
        // Basic scene setup
        this.setupScene();
        
        // Create a simple environment
        this.createEnvironment();
        
        // Add helpers for debugging
        this.addHelpers();
        
        // Setup input handlers
        this.setupInputHandlers();
        
        // Load and create character based on the selected character
        this.createCharacter();
        
        // Create camera controls for debugging
        if (this.debugMode) {
          this.setupDebugControls();
        }
        
        return this;
      }
      
      setupScene() {
        // Get reference to Three.js components
        this.scene = this.game.scene;
        this.camera = this.game.camera;
        this.renderer = this.game.renderer;
        
        // Set a cyberpunk background color
        this.scene.background = new THREE.Color(0x121212);
        
        // Position camera initially
        this.camera.position.set(0, 3, 8); // Standardized for all modes (adjust as per UI baseline)
        this.camera.lookAt(0, 0, 0);
        
        // Add cyberpunk accent lights
        this.addLights();
      }
      
      addLights() {
        // Add cyberpunk-style accent lights
        const purpleLight = new THREE.PointLight(0x9333EA, 1, 10);
        purpleLight.position.set(-5, 1, 0);
        this.scene.add(purpleLight);
        
        const greenLight = new THREE.PointLight(0x00FF66, 1, 10);
        greenLight.position.set(5, 1, 0);
        this.scene.add(greenLight);
      }
    
      createEnvironment() {
        // Create a simple ground plane
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshStandardMaterial({
          color: 0x333333, // Standard ground color per PRD
          roughness: 0.8,
          metalness: 0.2
        });
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
        ground.receiveShadow = true;
        this.scene.add(ground);
        
        // Add a few simple obstacles to test collision/movement
        this.addObstacle(-5, 0.5, -5, 1, 1, 1, 0x9333EA); // Purple box
        this.addObstacle(5, 0.5, -3, 1, 1, 1, 0x00FF66);  // Green box
      }
      
      addObstacle(x, y, z, width, height, depth, color) {
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshStandardMaterial({
          color: color,
          roughness: 0.7,
          metalness: 0.3
        });
        
        const obstacle = new THREE.Mesh(geometry, material);
        obstacle.position.set(x, y, z);
        obstacle.castShadow = true;
        obstacle.receiveShadow = true;
        
        this.scene.add(obstacle);
        this.objects.push(obstacle);
        
        return obstacle;
      }
    
      createCharacter() {
        const selectedCharacter = this.game.selectedCharacter || 'american';
        
        // Determine which model to load based on selection
        const modelPath = selectedCharacter === 'american' ? 
          'assets/models/American Cockroach.glb' : 
          'assets/models/Oriental cockroach.glb';
        
        console.log(`Loading cockroach model: ${modelPath}`);
        
        // Create a placeholder while the model loads
        this.createPlaceholderCockroach();
        
        // Load the actual model if GLTFLoader is available
        if (typeof THREE.GLTFLoader !== 'undefined') {
          console.log('GLTFLoader is available, loading model...');
          const loader = new THREE.GLTFLoader();
          
          // Add loading progress tracking
          loader.load(
            modelPath,
            (gltf) => {
              console.log('Model loaded successfully:', gltf);
              
              // Remove placeholder when the real model is loaded
              if (this.placeholder) {
                this.scene.remove(this.placeholder);
                this.placeholder = null;
              }
              
              // Process the loaded model
              this.cockroachModel = gltf.scene;
              this.cockroachModel.traverse(node => {
                if (node.isMesh) {
                  node.castShadow = true;
                  node.receiveShadow = true;
                }
              });
              
              // Scale and position the model appropriately
              this.cockroachModel.scale.set(0.5, 0.5, 0.5); // Standard scale for all modes
              this.cockroachModel.position.set(0, 0.5, 0);  // Lift it above the ground slightly
              
              // Log position for debugging
              console.log('Cockroach model positioned at:', this.cockroachModel.position);
              
              // Add to scene
              this.scene.add(this.cockroachModel);
              
              // Setup animations if any
              if (gltf.animations && gltf.animations.length > 0) {
                this.mixer = new THREE.AnimationMixer(this.cockroachModel);
                
                gltf.animations.forEach(clip => {
                  const name = clip.name.toLowerCase();
                  this.animations[name] = this.mixer.clipAction(clip);
                  
                  // Play idle animation by default
                  if (name.includes('idle')) {
                    this.animations[name].play();
                  }
                });
              }
              
              this.isModelLoaded = true;
            },
            (xhr) => {
              console.log(`Loading model: ${(xhr.loaded / (xhr.total || 1)) * 100}% loaded`);
            },
            (error) => {
              console.error('Error loading model:', error);
            }
          );
        } else {
          console.warn('THREE.GLTFLoader is not available. Using placeholder cockroach only.');
        }
      }
      
      createPlaceholderCockroach() {
        // Create a more visible placeholder cockroach 
        const bodyGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.6);
        const headGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        
        const material = new THREE.MeshStandardMaterial({ 
          color: 0xFF5500,  // Bright orange for visibility
          emissive: 0xFF2200, // Slight glow
          emissiveIntensity: 0.2
        });
        
        // Create body and head
        const body = new THREE.Mesh(bodyGeometry, material);
        const head = new THREE.Mesh(headGeometry, material);
        
        // Position head at front of body
        head.position.z = 0.35;
        head.position.y = 0.05;
        
        // Add legs (simple cylinders)
        const legGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.2);
        const legMaterial = new THREE.MeshStandardMaterial({ color: 0xFF5500 });
        
        for (let i = 0; i < 6; i++) { // 3 legs on each side
          const leg = new THREE.Mesh(legGeometry, legMaterial);
          leg.rotation.x = Math.PI / 2; // Make horizontal
          leg.position.y = -0.05; // Below body
          leg.position.z = 0.2 - i * 0.2; // Space them out along body
          
          // Left or right side
          leg.position.x = (i % 2 === 0) ? 0.2 : -0.2;
          body.add(leg);
        }
        
        // Create group for entire cockroach
        this.placeholder = new THREE.Group();
        this.placeholder.add(body);
        this.placeholder.add(head);
        
        // Position the placeholder higher above ground and scale it up
        this.placeholder.position.set(0, 0.5, 0);
        this.placeholder.scale.set(1.5, 1.5, 1.5);
        
        // Add to scene
        this.scene.add(this.placeholder);
        
        console.log('Enhanced placeholder cockroach created at position:', this.placeholder.position);
      }
      
      setupInputHandlers() {
        // Keyboard event listeners
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.handleKeyUp = this.handleKeyUp.bind(this);
        
        window.addEventListener('keydown', this.handleKeyDown);
        window.addEventListener('keyup', this.handleKeyUp);
      }
      
      handleKeyDown(event) {
        switch(event.code) {
          case 'KeyW':
          case 'ArrowUp':
            this.keys.forward = true;
            break;
          case 'KeyS':
          case 'ArrowDown':
            this.keys.backward = true;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            this.keys.left = true;
            break;
          case 'KeyD':
          case 'ArrowRight':
            this.keys.right = true;
            break;
          case 'Space':
            this.keys.jump = true;
            break;
          case 'KeyT': // Toggle debug mode
            if (this.debugMode) {
              this.disableDebugControls();
              this.debugMode = false;
            } else {
              this.setupDebugControls();
              this.debugMode = true;
            }
            break;
        }
      }
      
      handleKeyUp(event) {
        switch(event.code) {
          case 'KeyW':
          case 'ArrowUp':
            this.keys.forward = false;
            break;
          case 'KeyS':
          case 'ArrowDown':
            this.keys.backward = false;
            break;
          case 'KeyA':
          case 'ArrowLeft':
            this.keys.left = false;
            break;
          case 'KeyD':
          case 'ArrowRight':
            this.keys.right = false;
            break;
          case 'Space':
            this.keys.jump = false;
            break;
        }
      }
      
      setupDebugControls() {
        // Create debug camera controls
      if (typeof THREE.OrbitControls !== 'undefined') {
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
      } else {
        console.warn('THREE.OrbitControls is not available. Debug camera controls will not work.');
        return;
      }
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        console.log('Debug controls enabled (press T to toggle)');
      }
      
      disableDebugControls() {
        if (this.controls) {
          this.controls.dispose();
          this.controls = null;
          console.log('Debug controls disabled');
        }
      }
    
      update(delta) {
        // Handle keyboard input
        this.handleInput();
        
        // Update player movement
        this.updateMovement(delta);
        
        // Update camera position
        this.updateCamera();
        
        // Update animations
        if (this.mixer) {
          this.mixer.update(delta);
        }
        
        // Update orbit controls if in debug mode
        if (this.debugMode && this.controls) {
          this.controls.update();
        }
        
        // Log position of cockroach every few seconds (for debugging)
        if (this.cockroachModel && Math.random() < 0.01) {
          console.log('Cockroach position:', this.cockroachModel.position);
        }
      }
      
      updateCamera() {
        if (this.debugMode) return; // Skip if in debug mode with orbit controls
        
        // Get target (either cockroach model or placeholder)
        const target = this.cockroachModel ? this.cockroachModel.position.clone() : 
                      (this.placeholder ? this.placeholder.position.clone() : new THREE.Vector3(0, 0.5, 0));
        
        // Calculate new camera position based on target position
        const offset = new THREE.Vector3(0, 3, 5); // Camera offset behind and above the cockroach
        
        // Apply rotation if model exists
        if (this.cockroachModel) {
          offset.applyQuaternion(this.cockroachModel.quaternion);
        }
        
        const cameraPosition = target.clone().add(offset);
        this.camera.position.lerp(cameraPosition, 0.1); // Smooth camera movement
        
        // Look at target slightly above ground level
        const lookTarget = target.clone();
        lookTarget.y += 0.5; // Look at a point slightly above the cockroach
        this.camera.lookAt(lookTarget);
        
        // Log camera updates occasionally for debugging
        if (Math.random() < 0.01) {
          console.log('Camera position:', this.camera.position, 'Looking at:', lookTarget);
        }
      }
      
      // Handle keyboard input
      handleInput() {
        // Only move if we have a model
        const model = this.cockroachModel || this.placeholder;
        if (!model) return;
        
        const moveSpeed = this.moveSpeed * 0.01; // small delta for consistent speed
        const rotateSpeed = this.rotationSpeed * 0.01;
        
        // Handle rotation
        if (this.keys.left) {
          model.rotation.y += rotateSpeed;
          console.log('Rotating left, new rotation:', model.rotation.y);
        }
        if (this.keys.right) {
          model.rotation.y -= rotateSpeed;
          console.log('Rotating right, new rotation:', model.rotation.y);
        }
        
        // Handle movement
        if (this.keys.forward || this.keys.backward) {
          const direction = new THREE.Vector3(0, 0, this.keys.forward ? -1 : 1);
          direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), model.rotation.y);
          
          model.position.x += direction.x * moveSpeed;
          model.position.z += direction.z * moveSpeed;
          
          console.log('Moving, new position:', model.position);
        }
      }
      
      // Update movement physics, animations, etc.
      updateMovement(delta) {
        // Play animations if moving (if animations exist)
        if (this.mixer && this.animations) {
          // Animation logic here if needed
        }
      }
      
      // Add helper objects for debugging
      addHelpers() {
        // Add axis helper
        const axisHelper = new THREE.AxesHelper(5);
        this.scene.add(axisHelper);
        
        // Add grid helper
        const gridHelper = new THREE.GridHelper(20, 20);
        this.scene.add(gridHelper);
        
        console.log('Debug helpers added to scene');
      }
      
      dispose() {
        // Clean up resources and event listeners
        window.removeEventListener('keydown', this.handleKeyDown);
        window.removeEventListener('keyup', this.handleKeyUp);
        
        this.disableDebugControls();
        
        this.objects.forEach(obj => {
          this.scene.remove(obj);
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) obj.material.dispose();
        });
        
        // Clean up any animations/mixers
        if (this.mixer) {
          this.mixer.stopAllAction();
        }
        
        console.log('Free World mode disposed');
      }
    }
    
    // Initialize the game
    const game = new Game();
    
    // Start with American cockroach by default
    game.startGame('free-world', 'american');
    
    // Add character selection buttons
    document.getElementById('american-roach').addEventListener('click', () => {
      // Clear scene
      while(game.scene.children.length > 0){ 
        game.scene.remove(game.scene.children[0]); 
      }
      game.setupBasicLighting();
      
      // Start with American cockroach
      game.startGame('free-world', 'american');
    });
    
    document.getElementById('oriental-roach').addEventListener('click', () => {
      // Clear scene
      while(game.scene.children.length > 0){ 
        game.scene.remove(game.scene.children[0]); 
      }
      game.setupBasicLighting();
      
      // Start with Oriental cockroach
      game.startGame('free-world', 'oriental');
    });
  </script>
</body>
</html>
